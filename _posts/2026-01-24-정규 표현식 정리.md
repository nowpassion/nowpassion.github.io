---
layout: post
title: 정규 표현식 정리
author: nowpassion
date: 2026-01-24
tags: "손에_잡히는_10분_정규_표현식"
toc : false
---

## 정규 표현식의 구성 요소를 이해하는 것은 왜 중요한가?

(책 77 페이지를 유심히 봐라)

정규표현식은 단순히 기호들의 나열이 아니라, 서로 다른 역할을 가진 **모듈적 요소들**이 결합된 구조임.\
정규표현식을 작성하거나 해석할 때 **구성 요소를 구분해서 이해하는 것**은 필수적임.\
이걸 습관화하면 복잡한 정규식도 "블록 단위"로 쉽게 읽을 수 있고, 원하는 매칭을 정확히 설계할 수 있게 됨.

1. **역할 혼동 방지**
   - `.` 은 **메타문자** (임의의 문자)  
   - `*` 는 **수량자** (앞 패턴의 반복)  
   - 같은 기호처럼 보이지만 분류가 다르기 때문에, 구분해야 함.

2. **정확한 해석**
   - `^abc$` → 앵커(`^`, `$`) + 리터럴(`abc`)  
   - `^\s*abc` → 앵커(`^`) + 수량자(`*`) + 메타문자(`\s`)  
   - 어떤 부분이 "위치"를 의미하는지, 어떤 부분이 "문자"를 의미하는지 명확히 알아야 올바른 매칭을 기대할 수 있음.
   - 정규식은 “앵커(어디서 매칭할지)” + 패턴(무엇을 매칭할지)” + “수량자(얼마나 반복할지)” 요소들이 결합된 구조로 이해할 수 있음.

3. **복잡한 패턴 설계**
   - 그룹(`()`)과 수량자(`+`, `*`)를 혼합할 때, 각 요소의 성격을 모르면 원하는 결과를 얻기 어려움.
   - 예: `(ab)*` 와 `ab*` 는 완전히 다른 의미를 갖는다.

4. **디버깅과 유지보수**
   - 정규식은 한눈에 이해하기 어려운 경우가 많음.
   - 구성 요소를 분류해서 보면 "앵커 → 문자 클래스 → 수량자 → 그룹" 같은 구조가 드러나고, 수정이나 확장이 쉬워짐.

---

## 정규표현식 구성 요소의 계층적 분류

```
정규표현식
├── 앵커 (Anchor)
│   ├── ^ (문자열 시작)
│   └── $ (문자열 끝)
│
├── 패턴 (Pattern)
│   ├── 리터럴 문자 (Literal) : 'a', 'b', 'abc'
│   ├── 메타문자 (Metacharacter) : ., \d, \s, \w
│   ├── 문자 클래스 (Character Class) : [A-Z], [0-9], [^abc]
│   ├── 그룹 (Group) : (abc), (foo|bar)
│   └── 서브패턴 (Subpattern) : (?:xyz), (?=abc)
│
└── 수량자 (Quantifier) → 항상 앞의 패턴과 결합
    ├── *  : 0회 이상 반복
    ├── +  : 1회 이상 반복
    ├── ?  : 0회 또는 1회
    └── {n,m} : n회 이상 m회 이하 반복
```

---

## 📌 정규표현식의 주요 구성 요소
정규표현식은 여러 **구성 요소(category)** 들로 나뉘어 있음.

**앵커(anchor)**
1. **앵커(anchor)**
   - 문자열의 위치를 의미하는 독립적 기호.
   - 예: `^` (시작), `$` (끝)

**패턴(pattern)** 은 “수량자나 다른 제어 요소가 붙을 수 있는 기본 단위”들을 의미함.

2. **리터럴(literal) 문자**
   - 그냥 그 문자 자체를 의미.
   - 예: `a`, `b`, `abc`

3. **메타문자(metacharacter)**
   - 특별한 의미를 가진 기호.
   - 예: `.`, `\d`, `\s`, `\w`

4. **문자 클래스(character class)**
   - 대괄호 `[]` 안에 여러 문자 집합을 정의.
   - 예: `[A-Z]`, `[0-9]`, `[^abc]`

5. **그룹(group)**
   - 괄호 `()` 로 묶어 하나의 단위로 취급.
   - 예: `(abc)`, `(foo|bar)`

6. **서브패턴(subpattern)**
   - 캡처 그룹 `( ... )` 또는 비캡처 그룹 `(?: ... )`  
   - 예: `(?:xyz)+` → `"xyz"` 가 1회 이상 반복

**수량자(quantifier)**

1. **수량자(quantifier)**
   - 바로 앞 패턴이 몇 번 반복될 수 있는지 지정.
   - `*` → 0회 이상  
   - `+` → 1회 이상  
   - `?` → 0회 또는 1회  
   - `{n,m}` → n회 이상 m회 이하

**플래그(flags)**
1. **플래그(flags)**
   - 정규식의 동작 모드를 바꾸는 옵션.
   - 예: `i` (대소문자 무시), `m` (멀티라인), `g` (전역 검색).

---

## `.` vs `*` 예시로 보는 정규표현식 구성 요소 배치

- `.` → **메타문자** (임의의 한 문자) ("무엇을 매칭할지"를 정의하는 **패턴 요소**)
- `*` → **수량자** (앞 패턴의 0회 이상 반복) ("얼마나 반복할지"를 정의하는 **수량자**)

### 예시로 비교
- `a*` → `"a"` 가 0회 이상 반복 (`""`, `"a"`, `"aa"`, …)
- `.*` → 임의의 문자(`.`)가 0회 이상 반복 → 사실상 "아무 문자열"

### 수량자와 묶여야 하는 구성 요소

수량자는 **항상 앞에 오는 패턴과 결합**해서 해석할 수 있음.\
즉, 수량자가 붙을 수 있는 대상은 아래와 같음.

- **리터럴 문자** → `a*`  
- **메타문자** → `\d+`, `\s?`  
- **문자 클래스** → `[A-Z]{2,4}`  
- **그룹** → `(abc)?`, `(?:xyz)*`  
- **서브패턴 전체** → `(foo|bar)+`

**리터럴, 메타문자, 문자 클래스, 그룹, 서브패턴**은 모두 수량자와 묶여서 반복 규칙을 정의할 수 있음.

### 앵커는 수량자와 결합되지 않는다!
**앵커(anchor)** 는 독립적으로 해석되어 문자열의 시작(`^`), 끝(`$`)을 단독으로 판별.\
**앵커(anchor)** 는 수량자와 결합되지 않음.

---

## 메타 문자 동작 예시

1. 입력 문자열 : The cat sat on the mat.

2. 정규식 : \bcat\b
- \b → 단어 경계
- cat → 문자 그대로 "cat"
- \b → 다시 단어 경계

3. 탐색 과정
- 문자열을 왼쪽부터 스캔
- "The" → cat과 불일치
- " cat " → 여기서 c 앞에 공백이 있음 → 공백은 비단어 문자이고 c는 단어 문자 → 따라서 \b 조건 충족
- "cat" → 정확히 매칭
- "t 뒤에 오는 " " (공백) → 단어 문자(t)와 비단어 문자(공백)가 맞닿음 → 다시 \b 조건 충족

4. 매칭 결과
- "cat"이 단어 경계로 둘러싸여 있기 때문에 매칭 성공
- 결과: "cat" 부분이 하이라이트됨

