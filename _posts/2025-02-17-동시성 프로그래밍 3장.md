---
layout: post
title: 동기 처리 1
author: nowpassion
date: 2025-02-17
tags: 동시성 프로그래밍
---
## 레이스 컨디션
* 레이스 컨디션
  * 여러 프로세스가 동시에 공유하는 자원에 접근함에 따라 일어나는 예상치 않은 이상이나 상태
  * 여러 프로세스가 공유 메모리상의 변수를 증가시키는 상황
* 크리티컬 섹션
  * 레이션 컨디션을 일으키는 프로그램 코드 부분
  * 위 예시에서는 공유 메모리상의 변수

## 아토믹 처리
* 아토믹 처리란?
  * 더 이상 나눌 수 없는 처리 단위
  * CPU의 add 명령이나 mul같은 명령
  * 일반적으로는 여러 번의 메모리 접근이 필요한 조작이 필요한 처리
  ```
  어떤 처리가 아토믹하다. -> 해당 처리의 도중 상태는 시스템적으로 관측할 수
  없으며, 만약 처리가 실패하면 처리 전 상태로 완전 복원된다.
  ```
* Compare and Swap (CAS)
  * CAS는 세마포어, 락프리, 웨이트프리한 데이터 구조를 구현하기 위한 이용
  * 동작 방식
    * 바꾸기 전 값이 저장되어 있는 값과 다르면 false
    * 변경 성공 시 true
  * 일반적인 구문을 사용한 경우
    * 동작이 아토믹하지 않다.
    
    ```c
    bool campare_and_swap(uint64_t *p, uint64_t val, uint64_t newval)
    {
      if (*p != val) {
        return false;
      }

      *p = newval;
      return true;
    }
    ```
    ```
    gcc -g -O3 cas.c
    0000000000001140 <campare_and_swap>:
    {
      1140:       f3 0f 1e fa             endbr64
                  return false;
      1144:       31 c0                   xor    %eax,%eax
          if (*p != val) {
      1146:       48 39 37                cmp    %rsi,(%rdi)
      1149:       75 08                   jne    1153 <campare_and_swap+0x13>
          *p = newval;
      114b:       48 89 17                mov    %rdx,(%rdi)
          return true;
      114e:       b8 01 00 00 00          mov    $0x1,%eax
    }
      1153:       c3                      ret
    ```  
  * gcc의 atomic extention을 사용한 경우
    * 값을 비교하여 교환하는 동작을 lock 구문을 통해 메모리 접근이 배타적으로 이루어짐을 보증한다.
    * [legacy __sync 함수](https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fsync-Builtins.html)
    * [atomic 함수](https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fatomic-Builtins.html)

    ```c
    bool campare_and_swap(uint64_t *p, uint64_t val, uint64_t newval)
    {                                                                           
        return __sync_bool_compare_and_swap(p, val, newval);
    }                
    ```
    ```
    gcc -g -O3 cas.c
    00000000000011a0 <campare_and_swap>:
    {
      11a0:       f3 0f 1e fa             endbr64
      11a4:       48 89 f0                mov    %rsi,%rax
          return __sync_bool_compare_and_swap(p, val, newval);
      11a7:       f0 48 0f b1 17          lock cmpxchg %rdx,(%rdi)
      11ac:       0f 94 c0                sete   %al
    }
      11af:       c3                      ret
    ```
    * x86-64 lock prefix 의미
      * LOCK prefix가 붙은 명령어가 실행될 때, CPU는 시스템 버스를 잠금 상태로 전환한다. 
      * 이는 다른 프로세서나 코어가 해당 메모리 주소를 접근하지 못하도록 막는다. 이로 인해 해당 명령어가 원자적으로 실행된다.
      * 상세한 내용은 Intel® 64 and IA-32 Architectures Software Developer's  Manual Combined Volumes 3A, 3B, 3C, and 3D: System Programming Guided문서의 10.1 LOCKED ATOMIC OPERATIONS을 참고
* Test and Set (TAS)
  * 로직은 아래와 같다.

  ```c
  bool test_and_set(bool *p) 
  {
    if (*p)
      return true;
    else {
      *p = true;
      return false;
    }
  }
  ```
  * TAS도 아토믹하게 실행할 수 있는 내장함수를 제공한다.

  ```c
  type __sync_lock_test_and_set(type *p, type val)
  {
    type tmp = *p;
    *p = val;
    return tmp;
  }
  ```
  ```c
  /* tas.c */
  #include <stdbool.h>
  #include <stdatomic.h>

  bool test_and_set(volatile bool *p)
  {
    return __sync_lock_test_and_set(p, 1);                                              
  }
  ```
  ```
  gcc -O3 -c tas.c
  0000000000000000 <test_and_set>:
   0:   f3 0f 1e fa             endbr64
   4:   b8 01 00 00 00          mov    $0x1,%eax    # %eax = 1  (위 코드에서는 val = 1)
   9:   86 07                   xchg   %al,(%rdi)   # TAS : %al과 (%rdi)를 교환한다. 
   b:   84 c0                   test   %al,%al      # $al and %al 를 수행한 결과를 ZF에 기록
   d:   0f 95 c0                setne  %al          # ZF가 0이 아니면 %al을 1로 설정
  10:   c3                      ret
  ```
  * xchg에는 LOCK prefix가 생략되어 있다고 보면 된다.
  * [xchg 명령 설명](https://c9x.me/x86/html/file_module_x86_id_328.html)
  * __sync_lock_test_and_set 함수에서 설정한 플래그는 __sync_lock_release를 이용하여 해제할 수 있음.

  ```c
  void tas_release(volatile bool *p)
  {
    __sync_lock_release(p);
  }
  ```
* Load-Link/Store-Conditional
  * lock prefix를 통해 x86 계열 CPU 아키텍처는 메모리 접근을 배타적으로 수행
  * ARM, RISC-V, POWER, MIPS등의 CPU에서는 Load-Link/Store-Conditional (LL/SC) 명령을 이용하여 아토믹 처리를 구현한다.
  * 8bit 단위 명령
    * ldrxb (LL) / stxrb (SC) / clrex (클리어)
  * LL 명령은 메모릭 읽기를 수행할 때 프로세서에서 배타적으로 수행되도록 보장
  * SC 명령은 메모리 쓰기를 수행하는 명령
    * LL 명령으로 지정한 메모리로의 쓰기는 다른 CPU가 수행하지 않는 경우에만 쓰기가 성공함.
    * 중간에 다른 프로세스가 해당 메모리에 접근하여 쓰기가 발생하면 SC 쓰기 명령이 실패함.
  * LL / SC 명령에 a/l이 각각 붙어있는 경우 이어지는 명령이 해당 명령이 끝난 이후 실행되는 것을 보장함.
    * 이는 load-Aquire / store-reLease 를 의미한다. 
    * LL : 이어지는 명령이 해당 명령이 종료된 이후 실행됨을 보장함.
    * SC : 해당 명령이 실행되기 전 모든 명령이 실행되어짐을 보장함.
    * 메모리 배리어
  * clrex
    * ldxr등에서 배타적으로 읽기를 수행한 메모리 상태를 배타 접근 상태에서 열린 접근(open access) 상태로 되돌리는 명령어
  * ARM v8에서는 cas를 지원
    * [참고할 만한 내용](https://zenn.dev/junkawa/articles/compare-and-swap-spinlock)
  * x86-64 아키텍처에서 이를 검출하려면 해저드 포인터라는 기법을 사용해야 함.
    * ABA 문제

## 뮤텍스
* MUTEX
  * MUTual EXecution
  * 임계영역에 접근할 수 있는 프로세스 수를 1개로 제한하는 동기화 방법
  * TAS를 이용하여 구현할 수 있다.

  ```c
  bool lock = false;

  void some_func(void) 
  {
  retry:
    if (!test_and_set(&lock)) {

    } else {
      goto retry;
    }

    tas_release(&lock);
  }
  ```
* 스핀락 (spinlock)
  * 리소스가 비는 것을 기다리며(polling) 확인하는 락 획득방법
  * TAS를 이용

  ```c
  void spinlock_aqcuire(bool *lock)
  {
    while(test_and_set(lock));
  }

  void spinlock_release(bool *lock)
  {
    tas_release(lock);
  }
  ```
  * TTAS(test-and-test-and-set lock)를 이용
    * 아토믹 명령은 실행 속도상의 패널티가 크다. 
    * 그러므로 검사를 하고 나서 TAS를 수행하는 방법을 사용하면 성능 상 이득을 취할 수 있다.

  ```c
  void spinlock_aqcuire(volatile bool *lock)
  {
    for (;;) {
      while (*lock);  //test
      if (!test_and_set(lock))  //test-and-set
        break;
    }
  }

  void spinlock_release(bool *lock)
  {
    tas_release(lock);
  }
  ```

  * 유저랜드 스핀락 사용 시 주의할 점
    * 계속 루프를 통해 lock을 획득하려고 시도하게 때문에 임계 영역안에서의 처리량이 많은 경우 불필요한 CPU 리소스가 낭비될 수 있다.
    * 유저랜드 스핀락을 획득한 후 실행 중에 OS 스케줄러에 의해 대기 상태가 되어버리면 특히 페널티가 크다.
    * 일반적으로 Mutex는 context switching을 통해 대기 상태를 지원하도록 구현되어 있다. (Pthread의 mutex, 리눅스 커널의 mutex)
* Pthread의 뮤텍스
  * pthread_mutex_init, pthread_mutex_destroy
  * pthread_mutex_lock, pthread_mutex_unlock

## 세마포어
* 세마포어란?
  * 최대 N개 프로세스까지 동시에 락을 획득할 수 있는 동기화 기법
  * 뮤텍스는 1개 프로세스의 접근을 지원하는 세마포어라고 볼 수 있음.

  ```c
  #define NUM 4

  void semaphore_aqcuire(volatile int *cnt)
  {
    for (;;) {
      while (*cnt >= NUM);  //허용된 락의 갯수보다 많이 획득했다면 loop
      
      __sync_fetch_and_add(cnt, 1); //세마포어 카운트를 아토믹하게 하나를 추가

      if (*cnt <= NUM)
        break;

      __sync_fetch_and_sub(cnt, 1); //허용된 락의 갯수보다 많으면 다시 하나를 삭제
    }
  }

  void semaphore_release(volatile int *cnt)
  {
    __sync_fetch_and_sub(cnt, 1);
  }
  ```

* LL/SC 명령을 이용한 구현
  * LL/SC 명령을 이용하여 해당 세마포어에 배타적으로 접근 가능하도록 구현할 수 있다.
  ```
  .LBB0_1:
    ldr   w8, [x0]
    cmp   w8, #3
    b.hi  .LBB0_1
  .Ltmp1:
    ldaxr w2, [x0]
    cmp   w2, #4
    b.lo  .Ltmp2
    clrex
    b     .LBB0_1
  .Ltmp2:
    add   w2, w2, #1
    stlxr w3, w2, [x0]
    cbnz  w3, .Ltmp1
    ret
  ```
* 리눅스에서의 세마포어
  * 이름있는 세마포어, 이름없는 세마포어
  * 만약 프로세스간 세마포어를 공유하려면?
    * 이름있는 세마포어는 파일로 생성
    * 이름없는 세마포어는 별도의 공유 메모리가 필요

## 조건변수
* 거리의 신호등과 같은 동작
  * 빨간 불이면 멈추었다가 파란불이면 진행하는 순서
* pthread_cond 타입을 사용하여 조건 변수를 구현할 수 있음.
* pthread_cond 에 사용하는 조건 변수는 race condition하에 동작므로 먼저 mutex등을 통해 보호한 다음 사용해야 한다.
* 관련 함수
  * pthread_cond_signal()
  * pthread_cond_broadcast()
  * pthread_cond_wait()
  * pthread_cond_timedwait()

## 배리어 동기
* 배리어 동기란? 
  * barrier synchronization
  * 소풍을 예로 들자면
    * 소풍간 학생들이 한 장소에서 자유롭게 돌아다니다가 다른 장소로 옮길 때는 같이 모여서 이동하는 것과 같음.
* 스핀락 기반 배리어 동기
  * 변수가 특정 값을 넘어서면 코드의 다음 단계로 진행하도록 구현

  ```c
  void barrier(volatile int *cnt, int max)
  {
    __sync_fetch_and_add(cnt, 1);
    while (*cnt < max); //max까지 기다렸다가 같이 출발!!
  }

  void *worker(void *arg) {
    barrier(&num, 10);

    NULL;
  }
  ```

* Pthread의 조건 변수를 이용한 동기
  * 스핀락을 이용하면 불필요하게 CPU를 점유할 수 있음.
  * Pthread의 조건 변수를 이용하면 같은 효과를 이루면서 불필요한 점유를 줄일 수 있다.

  ```c
  void barrier(volatile int *cnt, int max)
  {
    pthread_mutex_lock(&mut);

    *cnt++;

    if (*cnt == max) {
      pthread_cond_broadcast(&cond);
    } else {
      do {
        pthread_cond_wait(&cond, &mut);
      } while (*cnt < max>)
    }

    pthread_mutex_unlock(&mut);
  }
  ```

## Readers-Writer 락 (Read-Write 락)
* 래이스 컨디션은 쓰기 동작에 의해 일어나는 것이다.
* 그러므로 쓰기만 배타적으로 수행하면 문제가 발생하지 않는다.
* 읽기만 수행하는 프로세스(Readers)와 쓰기만 수행하는 프로세스(Writers)를 구분하여 아래와 같이 제약사항을 지키도록 한다.
  * 락을 획득 중인 Readers는 같은 시각에 다수(0 이상) 존재할 수 있다.
  * 락을 획득 중인 Writers는 같은   시각에 1개만 존재할 수 있다.
  * Reader와 Writer는 같은 시각에 락 획득 상태가 될 수 없다.

* 스핀락 기반의 RW락

```c
void rwlock_read_acquire(int *rcnt, volatile int *wcnt)
{
  for (;;) {
    while (*wcnt);
    __sync_fetch_and_add(rcnt, 1);
    if (*wcnt == 0)
      break;
    __sync_fetch_and_sub(rcnt, 1);
  }
}

void rwlock_read_release(int *rcnt)
{
  __sync_fetch_and_sub(rcnt, 1);
}

void rwlock_write_acquire(bool *lock, volatile int *rcnt, int *wcnt)
{
  __sync_fetch_and_add(wcnt, 1);
  while (*rcnt);
  spinlock_acquire(lock); //writer 끼리 경쟁하기 위한 spinlock
}

void rwlock_write_release(bool *lock, int *wcnt)
{
  spinlock_release(lock);
  __sync_fetch_and_sub(wcnt, 1);
  
}
```

* pthread는?
  * pthread_rwlock을 사용하면 된다.
* 그럼 어느 상황에서 사용해야 하는가?
  * 동시에 수행되는 프로세스가 대부분이 Read 동작이고 크리티컬 섹션에서의 작업이 상대적으로 많을 때 (Lock을 수행할 때 기본적인 오버헤드는 존재한다.) 효율성을 보인다.
    * 그렇다고 크리티컬 섹션에서 너무 많은 작업을 하면 당연히 성능이 떨어질 것이다.

## Rust 동기 처리 라이브러리
* 뮤텍스
  * Rust의 동기 처리 라이브러리는 크리티컬 섹션 밖에서의 보호 대상  객체의 접근과 락 미해제를 타입 시스템으로 방지하는 특징을 가지고 있다.

  ```rust
  use std::sync::{Arc, Mutex};
  use std::thread;

  fn some_func(lock: Arc<Mutex<u64>>) {
      loop {
          //unwrap을 호출한 객체에 기본적으로는 복사를 수행한다
          //복사와 소유권 이동 둘다 가능한 시점에서 복사가 발생한다.
          let mut val = lock.lock().unwrap();
          *val += 1;
          println!("{}", *val);
      }
  }

  fn main() {
      // Arc는 스레드 세이프한 참조 카운터 타입의 스마트 포인터입니다.
      let lock0 = Arc::new(Mutex::new(0));
      // 아래 코드는 참조 카운터를 증가될 뿐 내용은 복사되지 않습니다.
      let lock1 = lock0.clone();

      let th0 = thread::spawn(move || {
          some_func(lock0);
      });

      let th1 = thread::spawn(move || {
          some_func(lock1);
      });

      th0.join().unwrap();
      th1.join().unwrap();
  }
  ```

  * Rust에서는 Mutex용 변수는 보호 대상 데이터를 보존하도록 되어 있어 락을 하지 않으면 보호 대상 데이터에 접근할 수 없다.
    * 반면 C 언어에서는 메모리 접근에 아무런 제약이 없다.
  * 보호 대상 데이터가 스코프를 벗어나면 자동으로 락이 해제된다.
    * 그러므로 Pthreads로 발생한 락의 취득과 해제를 잊어버리는 것을 방지할 수 있다.
  * Mutex crate의 lock()의 리턴 값은 LockResult<T> = Result<T, PoisonError<T>> 와 같다.
    * 즉 성공하면 T를 반납하고, 실패 시에 PoisonError<T>를 반환한다.
    * 한 쓰레드에서 락을 획득한 후 패닉(panic)에 빠지는 경우 이를 poisoned 상태 있다고 간주하고 락 획득에 실패한다.
* 조건 변수
  * Rust에서 조건 변수는 Condvar
  * 락을 획득한 다음 wait 또는 notify를 수행

  ``` rust
  use std::sync::{Arc, Mutex, Condvar};
  use std::thread;

  fn child(id: u64, p: Arc<(Mutex<bool>, Condvar)>) {
      let &(ref lock, ref cvar) = &*p;

      let mut started = lock.lock().unwrap();

      while !*started {
          started = cvar.wait(started).unwrap();
      }

      println!("child {}", id);
  }

  fn parent(p: Arc<(Mutex<bool>, Condvar)>) {
      let &(ref lock, ref cvar) = &*p;

      let mut started = lock.lock().unwrap();
      *started = true;
      cvar.notify_all();
      println!("parent")
  }

  fn main()
  {
      let pair0 = Arc::new((Mutex::new(false), Condvar::new()));
      let pair1 = pair0.clone();
      let pair2 = pair1.clone();

      let c0 = thread::spawn(move || { child(0, pair0) });
      let c1 = thread::spawn(move || { child(1, pair1) });
      let p = thread::spawn(move || { parent(pair2) });

      c0.join().unwrap();
      c1.join().unwrap();
      p.join().unwrap();
  }
  ```

* RW락
  * RW락도 존재한다.

  ``` rust
  use std::sync::RwLock;

  fn main () {
      let lock = RwLock::new(10);
      {
          // 참조를 얻어옴. (읽기만 가능)
          let v1 = lock.read().unwrap();
          let v2 = lock.read().unwrap();
          println!("v1: {}, v2: {}", v1, v2);
      }

      {
          // mut 참조를 얻어옴. (쓰기 가능)
          let mut v = lock.write().unwrap();
          *v = 7;
          println!("v1: {}", v);
      }
  }
  ```

  * 배리어 동기
    * 별도의 배리어 동기 타입이 존재한다.

  ``` rust
  use::std::sync::{Arc, Barrier};
  use::std::thread;

  fn main() {
      let mut v = Vec::new();

      let barrier = Arc::new(Barrier::new(10));

      for _ in 0..10 {
          let b = barrier.clone();
          let th = thread::spawn(move || {
              b.wait();
              println!("Thread finished");
          });

          v.push(th);
      }

      for th in v {
          th.join().unwrap();
      }
  }
  ```

* 세마포어
  * Rust에는 세마포어를 별도로 제공하지 않는다.
  * 2025.05 현재 : tokio 크레이트에서 세마포어 데이터 타입을 지원한다. ([링크](https://docs.rs/tokio/latest/tokio/sync/struct.Semaphore.html))
  * 아래는 책에서 Condvar, Mutex로 구현한 세마포어 코드이다.
     
  ```rust
  use std::sync::{Condvar, Mutex};

  pub struct Semaphore {
      count: Mutex<isize>,
      condvar: Condvar,
      max: isize,
  }

  impl Semaphore {
      pub fn new(max: isize) -> Self {
          Semaphore {
              count: Mutex::new(0),
              condvar: Condvar::new(),
              max,
          }
      }

      pub fn wait(&self) {
          let mut count = self.count.lock().unwrap();
          while *count >= self.max as isize {
              count = self.condvar.wait(count).unwrap();
          }
          *count += 1;
      }

      pub fn post(&self) {
          let mut count = self.count.lock().unwrap();
          *count -= 1;
          if *count <= self.max {
              self.condvar.notify_one();
          }
      }
  }
  ```

* 베이커리 알고리즘
  * 위 내용들은 모두 CPU에서 제공하는 아토믹 명령을 이용한 동기 처리 방법
  * 하지만 아토믹 동작을 지원하지 않는 CPU도 존재
  * 이를 위한 알고리즘 중 하나가 베이커리 알고리즘
  * Arm Trusted Firmware등에 구현되어 있음.([링크](https://github.com/ARM-software/arm-trusted-firmware/blob/master/lib/locks/bakery/bakery_lock_normal.c))
  * 데커 알고리즘, 피터슨 알고리즘 등...
  * 알고리즘 내용
    * 여러 객체가 티켓을 받는다.
    * 티켓에는 번호가 기록되어 있다.
    * 호출하는 측이 번호를 부르면 번호를 가지고 있는 객체가 처리된다.
  * 현대적인 CPU에는 아웃 오브 오더 기법이 적용되어 있음.
    * 즉 티켓 순서대로 접근 명령을 CPU에서 최적화를 위해 임의로 변경할 수 있다.
    * 베이커리 알고리즘을 구현하기 위해서는 메모리 배리어 (또는 메모리 펜스)를 이용하여 메모리 접근 순서를 보증해야 한다.