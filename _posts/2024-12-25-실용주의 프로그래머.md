---
title: 실용주의 프로그래머
author: nowpassion
date: 2024-12-25
category: Jekyll
layout: post
---
## 서문

1. 프로그래머라는 직업은 참 어려운 직업이다.
2. 정답은 없다. 오직 특정한 환경 조건의 집합마다 각 집합에 가장 적절한 시스템들이 있을 뿐이다.
   * 그 상황에서 좋은 해결방안을 고를 수 있도록 충분한 배경지식과 경험을 가져야 한다.
   * 배경지식 : 컴퓨터 과학의 기본 원리들을 이해하는 것
   * 경험 : 다양한 범위의 실제 프로젝트들을 수행해보는 것
3. 무엇이 실용주의 프로그래머를 만드는가?
   * __얼리어덥터 성향__ / 새로운 것에 빨리 적응하는 성향 : 기술 / 기법에 대한 감각을 추구하고, 새로운 시도를 통해 자기의 지식에 통합하려고 함.
   * __캐묻기 좋아한다.__ : 주변에서 보이는 궁금점에 대해 캐묻고 이를 자신의 지식에 보탠다.
   * __비판적인 사고의 소유자.__ : 사실 관계를 확인하지 않고서는 어떤 것도 들은 대로 믿는 일이 드물다.
   * __현실적이다.__ : 자신이 맞닥드리는 모든 문제의 근본적인 성격을 이해하려고 한다. 이는 결국 문제를 풀어나가는 지구력을 증가시키는 결과로 이어질 것이다.
   * __다방면의 기술에 익숙하다.__ : 넓은 범위의 기술과 환경에 친숙해지려고 열심히 노력한다. 그리고 이런 사람은 새로운 발전의 흐름에 뒤떨어지지 않으려고 노력한다. 지금 하는 일이 특정 분야를 좁게 파고들 것을 요구할지라도, 이런 사람은 언제든지 새로운 영역과 새로운 도전으로 옮겨갈 수 있다.
4. 소프트웨어 개발을 잘 하려는 관심과 애정이 없다면, 그 일을 하는 것에 아무 의미가 없다고 생각한다.
5. 절대 기계적으로 일하지 말라. 언제나 생각하고 언제나 일하면서 동시에 자신의 일을 비평하고 분석하라.
6. 프로그래머의 보상
   * 여러분의 사랑하는 직업에 더 적극적으로 참여할 수 있는 것
   * 점점 더 종류가 늘어나는 다양한 성격의 일에 숙달되어 가는 느낌
   * 지속적으로 발전하는 것을 느끼는 데서 오는 기쁨
   * 장기적으로 팀은 더 효율적으로 되고, 더 유지보수하기 쉬운 코드를 작성하게 될 것이며, 회의에 시간을 덜 들이게 될 것이므로 ***<mark style="color:red; background-color:lightblue;">(실제 중요한 문제에 대해 회의 시간을 더 사용할 수 있을 것)</mark>***[^1], 여러분이 투자한 시간은 충분히 보답 받을 것임.
7. 프로젝트의 전체 구조 속에는 언제나 개성과 장인 정신(craftmanship)이 발휘 될 여지가 있다.
8. 매일 같이 지금 있는 기술들을 더 다듬고, 여러분 기술 목록에 새로운 도구들을 추가하라.<br />
***<mark style="color:red; background-color:lightblue;">(이 블로그를 작성하는 진정한 목적 - 하면 좋다!!)</mark>***
9. 책을 읽다가 전에 본 적 없는 단어와 마주치게 된다면 부탁하건데 그냥 건너뛰지 말라.<br />
***<mark style="color:red; background-color:lightblue;">(일반론적인 책은 이런 자세가 좋으나, 신규 기술에 대한 책을 읽을 때에는 적당히 넘어가고 다시 읽는 것이 좋다고 생각한다.)</mark>***[^2]

## 1. 실용주의 철학
### 1. 고양이가 내 소스 코드를 삼켰어요
* 실용주의 프로그래머는 경력에 대해 책임을 지고, 자신의 무지나 실수를 인정하기를 두려워하지 않는다.
   * 철저한 테스트, 훌륭한 문서화, 탄탄한 자동화 등에도 불구하고 문제는 생긴다.
   * 자신의 능력에 대해 자부심을 가질 수 있지만 실수나 무지 같은 점에 대해서도 정직해져야 한다.
   * __책임지기__
     * 최선을 다하라. 거기에 자신의 통제에 벗어나는 위험요소에 대해 상황을 분석해야 한다. 
     * 문제가 발생했을 경우 어떤 대안을 제시할 지 미리 생각하라.
     * 변명 대신 상황을 개선시킬 수 있는 대안을 제시하라.

### 2. 소프트웨어 엔트로피
* 엔트로피 (entropy) : 시스템 내의 '__무질서__' 한 정도를 가리키는 물리학 용어
* 소프트웨어도 시간이 지나면 부패한다.
* __깨진 창문__
  * 깨진 창문을 발견하면 수정해라.
  * 발견 즉시 수정해라. 또는 표지판(판자)등으로 표시하여 추후에라도 바로 수정할 수 있도로 최소한의 조치를 수행하라.
  * 깨진 창문 하나는 결국 전체 프로젝트에 깨진 창문을 증가시키는 시발점이 될 수 있다.

### 3. 돌멩이 수프와 삶은 개구리
* 돌멩이 수프
  * 시작 피로 (startup fatigue) : 무엇인가 막 시작하려고 할 때 많은 에너지를 쏟아야 하는 경우가 생길 수 있는데, 이에 대한 방어기제를 의미함.
  * 구성원들의 시작 피로를 줄이기 위해 돌멩이를 내놔야 다른 사람들이 수프를 만들기 위한 나머지 재료를 내어 놓을 것이다.
  * ***즉 잘 동작하는 무엇인가를 만들고 보여주면 사람들이 거기에 대한 의견이나 자료를 공유할 것이다.***
* 삶은 개구리
  * 개구리와 물을 냄비에 넣고 천천히 온도를 올리면 개구리는 온도가 서서히 오르는 것을 감지 못할 것이고, 결국 삶아질 때 까지 그냥 그대로 있을 것이다.
  * 이는 깨진 창문과 다르게 구성원들이 변화를 감지하지 못하고 잘못된 길로 들어서는 것을 못 알아차리는 것이다.
  * ***결론적으로 이를 방지하기 위해서는 큰 그림에도 늘 관심을 가지고 주의를 기울여야 한다. 개인적으로 하는 일에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는지 지속적으로 살펴야 한다.***
* ***<mark style="color:red; background-color:lightblue;">개발을 진행할 때 삶은 개구리가 아닌 돌멩이 수프를 만들도록 노력하고 공유해야 한다.</mark>***

### 4. 적당히 괜찮은 소프트웨어
* 적당히 괜찮은 소프트웨어라는 것은 너덜너덜하거나 형편없는 코드를 의미하지 않는다.
* 적당히 괜찮은 소프트웨어라는 것은 사용자가 결정해주는 것을 의미한다.
* 이를 위해서는 사용자의 요구사항이 품질 명세에 포함될 수 있도록 소통하는 것이 중요하다.
  * 이렇게 되면 최대한 정확한 지점에서 소프트웨어 개발을 중지할 수 있게 된다. 그리고 남은 시간을 다른 의미있는 일에 사용할 수 있게 된다.

### 5. 지식 포트폴리오
* 시간이 지나면서 여러분의 지식 가치가 점점 떨어짐에 따라, 회사나 클라이언트에 대한 여러분의 가치가 역시 떨어진다. 이를 위해서는 어떻게 해야하는가?
* 지식 포트폴리오
  * __주기적인 투자__ : 항상 주기적으로 습관을 들여서 지식을 쌓아야 한다.
  * __다각화__ : 여러 기술을 함께 배우면 기술의 변화에 좀 더 유연하게 대응할 수 있다.
  * __리스크 관리__ : 기술은 하이 리스크, 하이 리턴 / 로우 리스크, 로우 리턴 둘 다 존재하므로 적절히 투자하는 것이 좋다.
  * __싸게 사서 비싸게 팔기__ : 새로게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습하는 것은 어렵지만, 이를 해낼 수만 있다면 매우 가치가 높게 평가될 수 있다.
  * __검토 및 재조정__ : 기술은 유동적이므로 배우고 투자하는 기술이 유효한 기술인지 항상 평가하라. (혼자 또는 여럿이)
* 목표 : 책에서 제한하는 행위
  * 매년 새로운 언어를 최소 하나는 배워라 : 다른 언어는 문제를 다르게 푼다. 이를 통해 기존의 언어를 통해서도 다르게 문제를 해석할 여지가 생길 수 있다.
  * 기술 서적을 분기마다 한 권씩 읽어라. : 현재 사용하는 기술이 익숙해졌다고 판단되면 다른 기술로 범위를 넓혀도 된다.
  * 비 기술 서적도 읽어라. : 컴퓨터를 사용하는 것은 사람이다. 사람을 만족시키는 것은 결국 사람에 대해 공부를 해야한다는 이야기이다.
  * 수업을 들어라. : 대학, 시사회, 세미나, 회사 등 여러곳에서 진행되는 수업을 들어라. (사람으로부터 배우는 것이 가장 효과적)
  * 지역 사용자 모임에 참여하라. : 회사 밖에 사람들이 무엇을 하는지 아는 것은 중요하다.
  * 다른 환경에서 실험해보라 : 여려 운영체제, 에디터, 컴파일러를 가지고 실험해보라. 배울 점이 생길 수 있다.
  * 요즘 흐름을 놓치지 마라.
  * 언터넷을 이용하라. : 신뢰할만한 원천을 찾으면 좋다. (인공지능은 어디까지 믿을 수 있을까?)
* 학습의 기회
  * 누군가 모르는 내용을 물어보면 그것을 인정하는데만 그치지 말고, 답을 찾아 나를 발전시킬 수 있도록 하자.
  * 독서와 연구는 시간이 걸리고, 시간은 늘 부족한 자원이다. 그래서 미리 계획해야 할 필요가 있다. 시간을 위해 늘 읽을거리를 준비하자.
* 비판적 사고
  * 지식을 습득하는 데 있어 항상 비판적으로 생각하는 것이 중요하다.
  * 인터넷의 지식은 (또한 인공지능의 지식) 정확하지 않을 수 있으니 한번 더 생각해보자.
  * 책의 경우 인터넷보다 정보가 정확할 확률이 높다.

### 6. 소통하라!
* 말하고 싶은 게 무언지 알아라
  * 스스로 말하고자 하는 것이 정확히 무엇인지 아는 것이 가장 어렵다.
  * 무엇을 말할지 미리 계획하라.
  * 개요를 작성하라.
  * 스스로 자문하라. (말하고자 하는 내용이 잘 전달되겠는가?)
  * ***문서, 전화통화, 메일 등 모든 의사소통 방식에 적용하라.***
* 청중을 알아라
  * 청중이 무엇에 관심이 있는지, 어느 정도의 능력이 있는지 생각하고 소통하라.
  * WISDOM - 청중 이해하기
  ```
  무엇(What)을 배우길 원하는가?
  말하려는 것에서 그들이 관심(Interest) 있어 하는 건 무엇인가?
  얼마나 소양(Sophisticated)이 있는가?
  어느 정도의 구체적인(Detail) 내용을 원하는가?
  누가 정보를 소유(Owe)하길 원하는가?
  그들이 경청하도록 동기(Motive)를 주려면 어떻게 해야 할까?
  ```
* 때를 골라라
  * 청중이 무엇을 듣기 원하는지 이해하기 위해서는, 그들의 우선순위를 알아야 한다.
  * 말하는 내용 뿐만 아니라 말하는 시간도 중요하다.
  * 주제를 선택하는 것에 대해 시의적적한가?
* 스타일을 골라라
  * 청중들이 원하는 스타일은 다양한다.
  * 직책, 나이, 부서, 성격에 따라 다를 수 있으니 최대한 고려하자.
  * 너무 어려우면 미리 양해를 구하자. (내용이 많아 또는 필수적인 내용이 있어 요약이 어렵다. 등...)
* 멋져 보이게 하라
  * 너무 형편없는 디자인은 내용 전달을 어렵게 할 수 있다.
  * 맞춤법 검사를 해라.
* 청중을 참여시켜라
  * 문서 작성을 진행할 때 청중의 반응을 미리 보면 좋다.
* 청자가 되어라
  * 질문을 해서 사람들이 이야기를 하도록 복돋우거라, 여러분이 한 말을 그들이 요약하도록 하라.
* 응답하라
  * 내가 응답을 못하는 경우는 얼마나 있나? (무례한 경우를 최대한 만들지 마라.)
  * 단순히 "다음에 답해 드리겠습니다." 라고 할지라도 언제나 이메일과 음성 메일에 답을 하도록 하라.

## 2. 실용주의 접근법
### 7. 중복의 해악
* ***<mark style="color:red; background-color:lightblue;">재사용하기 쉽게 만들어라!</mark>***
* 시간이 지나면서 생기는 모든 불안정성은 우리가 소위 유지보수 모드에서 시스템에 대한 지식을 재조직하고 재표현하는 데 대부분의 시간을 보내게 되리라는 것을 의미함.
* 프로그램에 지식이 중복되는 순간, 유지 보수의 악몽이 시작됨.
* 소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY 원칙이라고 부르는 것을 따르는 것
  * DRY : Don't Repeat Yourself
  * 이를 따르지 않는다면 프로그램 내에 스스로의 자기 모순에 빠져 서로 충돌하게 될 것이다.
* 어떻게 중복이 생기는가?
  * 강요된 중복
    * 프로젝트 결과 문서에서 중복을 강요하는 경우
    * 같은 기능에 대해 각각의 다른 플랫폼에서 개발해야 하는 경우에 코드의 중복
    * 프로그래밍 자체에 의해 정보가 중복되는 구조를 요구하는 경우
    * ***이를 해결하기 위한 방법으로 책에서는 아래와 같은 방법을 제시하고 있음.***
      * 정보의 다양한 표현방식 : 실제로 어떤 방법이 존재하는가?
      * 코드내에 문서화 : 낮은 차원은 내용은 코드로 표현, 높은 차원의 지식은 주석으로 추가 설명
      * 문서화와 코드 : 코드 - 테스트 - 문서화를 동시에 수행할 수 있으면 가장 좋다.
  * 언어에 관한 문제
    * C, C++ : extern을 여기저기 코드에 포함하게 되면 이에 대한 중복이 일어나게 됨다. (추후 type 및 이름 정보 수정이 필요)
    * 헤더 파일에는 인터페이스에 대한 사항을 기록하고, 구현 파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록하라.
  * 부주의한 중복
    * 프로그래머에 의한 중복
    * 책에 나와있는 예제

    ```c++
    // 수정 전
    class Line {
        public:
            Point   start;
            Point   end;
            double  length;
    }

    // 수정 후
    class Line {
        public:
            Point   start;
            Point   end;
            double  length() {
                 return start.distanceTo(end);
            }
    }
    ```

    * cache가 필요한 정보가 존재할 경우 그에 맞춰서 구현하면 된다.
  * 참을성 없는 중복
    * 모든 프로젝트는 시간의 압박을 받는다.
    * 시간 압박으로 인해 원래의 것을 복사하고 약간만 바꾸도록 유혹받을 것임.
    * 정도(正道)로 가는 길이 진정한 지름길이다. : 이를 지키지 않을 경우, 더 많은 시간을 잃어버릴 수 있음.
    * Y2K : 날짜 필드의 크기를 매개변수로 넣지 않았거나 날짜 서비스를 하나의 라이브러리에 집중해 구현하지 않으려는 개발자들에 의해 일어난 문제
  * 개발자간의 중복
    * 서로 다른 개발자가 동시에 기능을 개발하면서 발생할 수 있는 중복
    * 개발된 전체 기능 집합이 부주의하게 중복 될 수 있음. 그런 중복은 수년간 발견되지 않을 수 있으며, 이는 결국 유지 보수 문제로 귀결될 것이다.
    * 높은 수준의 해결책
      * 깨끗한 설계
      * 강력하고 기술적인 프로젝트 리더
      * 깨끗한 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것
    * 빈번한 소통을 통해 공통의 문제를 다룰수 있도록 한다.
      * 소통의 결과를 기록하면 좋다. 프로젝트 사서를 임명하여 프로젝트 인원간의 행위를 보조한다.
      * 소스 트리의 한 가운데에 유틸리티 루틴과 스크립트들이 저장될 수 있는 장소를 마련하라.
      * 코드 리뷰 시 다른 사람의 소스코드와 문서를 읽도록 하라. (이 행위는 배움의 기회이다.)
      * 다른 사람이 여러분의 코드를 들여다 본다고 해서 기분 나빠하지 말 일이다.

### 8. 직교성
* Orthogonality
* 컴퓨팅에서의 이 용어는 일종의 독립성이나, 결합도 줄이기(decoupling)를 의미한다.
  * 잘 설계된 시스템에서는 DB 코드가 사용자 인터페이스에 대해 직교할 것이다.
* 비직교적인 시스템
  * 헬리콥터 조종은 단연코 직교적이지 않다! [ (Helicopter_flight_controls)](https://en.wikipedia.org/wiki/Helicopter_flight_controls)
* 직교성의 장점
  * 생산성 향상
    * 변화가 국소화되서 개발 시간과 테스트 시간이 줄어든다.
    * 직교적인 접근법은 또한 재사용을 촉진한다.
    * 직교적인 컴포넌트 간 결합은 비직교적인 컴포넌트 간 결합에 비해 더 많은 기능을 수행할 가능성이 있다.
  * 리스크 감소
    * 감염된 코드는 격리될 것이다.
    * 시스템이 잘 깨어지지 않을 것이다.
    * 단위 테스트를 진행하기 쉽다.
    * 써드파트 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정된다. 이에 의존성이 줄어들 것이다. (커널 드라이버 모델을 참고)
* 프로젝트 팀
  * 팀 내 업무가 겹치는 영역이 많다면 구성원들은 책임 영역에 대해 혼동하게 된다.
  * 그러므로 중복이 최소화된 그룹으로 만들 수 있을까?
* 설계
  * 시스템은 협력하는 모듈들의 집합으로 구성되어야 한다.
  * 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다.
  * 레이어식 접근은 직교적 시스템을 설계하는 강력한 방법이다. [ (Linux Kernel Map)](https://en.wikipedia.org/wiki/File:Linux_kernel_map.png)
* 툴킷과 라이브러리
* 코딩
  * 코드의 결합도를 줄여라.
    * shy code를 작성하라 : 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.
  * 전역 데이터를 피하라.
    * 코드가 전역 데이터를 참조할 때마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다.
    * 만약 코드를 Multithread 형태로 변경해야 한다면 전역 데이터를 접근 하는 코드는 race condition 이 발생할 수 있다. 결국 모듈 간에 context 를 명시적으로 건네주는 코드를 작성했다면, 예상하지 못한 race condition에 의한 버그를 줄일 수 있을 것이다.
  * 유사한 함수를 피하라.
    * 필요에 의해 비슷한 코드를 작성하는 것은 있을 수 있지만, 결국 수정점이 생기면 추후 문제점이 발생할 여지가 크다.
    * 중복 코드는 문제의 징후다. 
  * 자신이 작성한 코드를 항상 비판적으로 검토해보는 습관을 기르기 바란다. (Refactoring)
  * 테스트
    * 직교성이 높은 코드는 Unit테스트를 진행하기 쉽다.
    * 테스트케이스를 포함한 Unit테스트도 정규 빌드 과정에 포함되어야 한다고 생각한다.(저자 생각)
    * 만약 Unit테스트를 진행해야 하는데 다른 모듈의 기능이 필요해 컴파일/링크 과정에서 필요하다면 이는 곧 불필요한 결합도가 존재하는지 확인해봐야 한다.
    * 하나의 버그 수정이 다른 모듈들에 얼마나 영향을 미치는지 확인해보고 필요 시 추가 조치를 해라.
      * 버그 수정 단위 별로 문제점이 얼마나 발생하는 지 확인해보는 것도 좋다.
* 문서화
  * 문서도 직교적으로 작성할 수 있다.(스타일시트 및 매크로)
* 직교적으로 살아가기
  * DRY 원리로 무장하고 직교성 원리를 충실히 사용한다면, 개발하고 있는 시스템이 더 유연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도 쉬워질 것이다.
  * 사람들이 뭐 하나 변경하기 위해 필사적으로 아등바등해야 하는 프로젝트에 투입되고 있다면, 이는 직교적으로 설계되지 않거나 코딩되지 않았을 것이다. 이제 Refactoring 할 시간이다.

### 9. 가역성
* ***<mark style="color:red; background-color:lightblue;">최종 결정이란 없다! (미래 환경까지 모두 담아내는 완벽한 코드는 없다.)</mark>***
* 유연하고, 적응 가능한 소프트웨어를 만드는 방법
  * DRY 원리, 결합도 줄이기, 메타데이터 사용하기를 따른다면 중요하면서도 되돌릴 수 없는 결정을 가능 한 줄일 수 있게 될 것이다.
* 여러 현실적인 상황에서도 대응할 수 있는 방법이 있어야 한다. (인원, 개발 환경, 개발 모델 등...)
* 유연한 아키텍쳐
  * 다양한 언어, 다양한 플랫폼에서 개발은 어떻게 할 것인가?
  * RPC 등을 통해 최대한 설계를 나눠서 한다면 급격한 요구사항에 대비할 수 있을 것이다. (CORBA, gRPC, Apache Thrift, JSON-RPC, XML-RPC)
  * 적절한 캡슐화가 되어 있지 않고, 결합도가 높으며, 하드코딩된 조직과 매개변수가 많다면, 급격한 요구사항 대비가 불가능할 것이다.
* 어떤 하나의 제한된 결정만을 수행하는 프로그램을 작성하지 않았는지 생각해보자. (설정 파일등을 통해 다양한 실행 환경 및 실행 모델을 결정할 수 있도록 하면 좋다.)
* 만약 벤더 의존적인 코드를 깨끗하게 분리하지 못하면 어떻게 될까?
  * 벤더 의존적인 수행문들이 코드 전반에 흩어져 있을 것이고, 이는 유지 보수 및 신규 코드 추가에 극도로 방해가 될 것이다.

### 10. 예광탄
* 현재 : 예광탄 코드를 빨리 작성할 수 있는 환경이 존재한다. (Chatgpt, Github Copilot등 AI)
* 큰 뼈대를 예광탄 코드로 만들자.
  * 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다.
  * 예광탄 코드는 완전한 기능이 들어있지 않을 뿐이다.
* 예광탄 개발 방법은 점진적인 개발 방법이다. (변화에 대한 요구와 추가한 기능을 언제나 생기기 마련이다.)
* 장점
  * 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
  * 개발자들은 들어가서 일할 수 있는 구조를 얻는다.
  * 통합 작업을 수행할 기반이 생긴다.
  * 보여줄 것이 생긴다.(결정권자에게 보고할 내용이 생긴다.)
  * 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.
* 예광탄이 언제나 목표물을 맞추는 것은 아니다.
  * 실제 개발 진행되고 있는 내용이 사용자들이 원하지 않는 것일 수 있다.
  * 빠른 대응책을 마련할 수 있다.
* 예광탄 vs 프로토타입
  * 프로토타입은 나중에 버릴 수 있는 코드로 작성할 수도 있다.
  * 예광탄 코드는 기능은 별로 없지만 그 시점에서는 완결된 코드다.
    * 최종 시스템의 일부를 이룬다.
  * 프로토타입은 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 수집 개념을 보면 된다.

### 11. 프로토타입과 포스트잇
* 자동차 업계에서는 신차 디자인을 개발하기 위해 다양한 프로토타입을 만들어 본다. (풍동 시험 등을 위해)
* 소프트웨어 개발에서도 프로토타입을 통해 위험 요소를 분석하고 노출시키며 이를 매우 저렴한 비용으로 바로잡을 기회를 얻는 것이다.
* 프로토타입을 꼭 코드로 작성하지 않아도 된다. (포스트잇, 화이트보드, 페인트 프로그램, 인터페이스 빌더 등...)
* 상세한 사항까지 보여줘야 하는 상황이면, 프로토타입 대신 예광탄 방식을 고민해라.
* 프로토타입의 대상
  * 위험을 수반하는 모든 것
  * 이전에 해본 적이 없는 것
  * 최종 시스템에 매우 중요한 것
  * 실험적이거나, 의심이 가는 것, 심적으로 편하지 않은 것
```
아키텍쳐
기존 시스템에 추가할 새로운 기능
외부 데이터의 구조 혹은 내용
써드파트 도구나 컴포넌트
성능 문제
사용자 인터페이스 설계
```
* 프로토타이핑은 학습 경험이며, 프로토타입의 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다.
* 프로토타입을 어떻게 사용할 것인가?
  * 프로토타입을 만들 때 무시해도 좋은 세부사항은 무엇인가?
    * 정확성 (correctness) : 적절히 가짜 데이터를 사용할 수 있음.
    * 완전성 (completeness) :  제한된 기능만 제공함.
    * 안정성 (robustness) : 에러 검사는 불완전하거나 완전히 무시될 수 있다.
    * 스타일 (style) : 주석이나 문서를 완전히 포함하지 않아도 된다.
  * 완전하지 않지만 동작하는 프로그래밍 언어를 사용해서 만들어 보라. (Tcl, Perl, Python 등...)
    * SWIG (Simplified Wrapper and Interface Generator)
    * 참고 : SWIG와 비슷한 기술 (Microsoft Copilot을 통해 검색한 내용)
      * Cython: Python 코드를 C로 컴파일하여 성능을 향상시키는 도구입니다. Python 코드를 C로 변환하고, 이를 통해 더 빠른 실행 속도를 얻을 수 있습니다.
      * CppSharp: C++ 코드를 다양한 고급 언어(예: C#, Java)로 연결하는 도구입니다. SWIG와 유사하게 인터페이스를 생성하여 다양한 언어에서 C++ 코드를 사용할 수 있게 합니다.
      * Boost.Python: Boost 라이브러리의 일부로, C++ 코드를 Python에서 사용할 수 있게 해주는 도구입니다. SWIG와 유사한 기능을 제공하지만, Boost 라이브러리의 일부로 제공되므로 추가적인 세팅이 필요하지 않습니다.
      * PyBind11: C++11을 사용하여 Python과 C++를 연결하는 라이브러리입니다. SWIG와 유사한 기능을 제공하지만, 더 쉽고 간단한 인터페이스를 제공합니다1.
      * JavaCPP: C++ 코드를 Java에서 사용할 수 있게 하는 도구입니다. SWIG와 유사한 기능을 제공하지만, Java 환경에서 사용됩니다.
* 아키텍쳐 프로토타이핑
  * 아키텍쳐 프로토타이핑 시 기대하는 것은 전체적으로 시스템이 어떻게 돌아가는지에 대한 감을 잡는 것이다.
  * 아키텍쳐 프로토타이핑에서 규명할 만한 사항은?
    * 주요 컴포넌트의 책임이 잘 정의되었고 적절한가?
    * 결합도는 최소화되었는가?
    * 잠재적 중복을 찾아낼 수 있는가?
    * 인터페이스 정의와 제약 사항은 수용할만한가?
    * ***각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가?***
    * ***모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?***
* 어떻게 프로토타입을 사용하지 않을 것인가?
  * 고객, 사용자의 기대가 프로토타입보다 더 많은 것을 기대할 때
  * 프로토타입 사용 시에는 프로토타입이 임시적인 내용이고, 이를 구체적으로 사용하지 않을 것임을 확실히 주지시켜야 한다.
  * 프로토타입을 적절히 사용하면 실수를 저렴하면서 동시에 손쉽게 고칠 수 있는 개발주기 초기에, 잠재적 문제 지점을 발견하고 또 고칠 수 있을 것이다.

### 12. 도메인 언어
```
내 언어의 한계가 곧 내 세계의 한계이다. (Die Grenzen meiner Sprache bedeuten die Grenzen meiner Welt.)
- 루트비히 비트겐슈타인 (Ludwig Wittgenstein)
```
* Lisp로 어떤 해결 방안을 설계하면 C 방식의 생각에 기반한 해결 방안과 다른 결과를 낳게 되며, 그 반대도 마찬가지다.
* 문제 도메인에 가까운 프로그램을 하는게 좋다.
  * Gradle(Java 자동 빌드), SQL (데이터베이스 상호작용), JinJa(HTML 템플릿 엔진), Makefile(컴파일/빌드 자동화) 등...
* 책에서는 소형 언어를 제안하고 있다. 또는 BNF 문법을 사용하는 것도 제안하고 있다.
  * bison & flex 를 통해 언어 체계를 만들어 볼 수 있다.
* 데이터 언어와 명령형 언어
  * 여러분이 구현하는 언어는 서로 다른 두 가지 방법으로 쓰일 수 있다.
  * 데이터 언어 : 어플리케이션이 사용할 어떤 형식의 데이터 구로를 만든다. 이런 어어는 환경설정 정보를 표현하기 위해 쓰이는 경우가 많다.
    * sendmail 프로그램의 환경설정
    * 윈도우 .rc 파일 : 메뉴, 위젯, 대화상자, 기타 윈도우 자원들을 기술
  * 명령어 언어
    * 실제로 실행되며 문장이 있고, 제어 구조체등을 가질 수 있다.
    * 유지보수를 쉽게 하기 위해서도 스스로 명령어 언어를 만들어 사용할 수 있다.
      * 예제 : 터미널 어플리케이션에서 출력되는 정보를 GUI 개발에 통합하는 과정
        * Expect 프로그램을 통해 터미널 어플리케이션 정보를 hooking하여 GUI 모듈에 전달해주는 코드를 작성할 수 있다.
      * 메인프레임 어플리케이션이 변경되어 필드들의 위치가 바뀌면, 유지보수 프로그래머는 C코드의 세부사항을 헤집고 다닐 필요 없이 단순히 고차원 기술 파일인 이 스크립트만 갱신하면 된다.
* 독립 언어와 내장 언어
  * 메타프로그래밍
  * 꼭 미니 언어만이 아닌 고차원 명령형 언어를 포함시킬 수 있다.
    * Jython (Java로 작성된 Python 인터프리터)
    * Groovy (Java를 위한 동적 스크립트 언어)
    * 이를 통해 어플리케이션의 동작을 동적으로 수정할 수 있다.
  * 결국 이를 통해 얻는 이점은 유지 보수 개념에서 유연한 대응을 기대할 수 있다는 점이다.

### 13. 추정
* 얼마나 정확한 것이 충분히 정확한 것인가?
  * 추정을 요구 받았을 때 먼저 검토해야 할 것은 "답변이 어떤 상황에서 사용될 것인가?" 이다.
  * 추정의 단위에 따라 답변의 정확도가 결정될 수 있다. (130일 vs 6달)
    * 필요한 일들을 끝내고, 프로젝트에 대략 125근무일이 소요될 것으라고 판단되면 대략 6달이라고 이야기하라.
* 추정치는 어디에서 오는가?
  * 일단 일을 해본 사람에게 물어보는 게 정확할 것이다. (경험의 중요성)
  * 판단이 안되면 주변 사람들과 많이 이야기 해보면 답이 나올 수 있다.
* 무엇을 묻고 있는지를 이해하자
  * 추정치를 질문 받았을 때는 우선 상대방이 정확히 무엇을 원하는 지 확인하는 것이 중요하다.
  * 추정을 하기 전 놓여진 상황에 미리 생각하는 습관을 들이도록 하자.
    * "교통사고가 일어나지 않고, 연로가 떨어지지 않는다면 20분 이내에 도착할 것입니다."
* 시스템의 모델을 만들어보라
  * 클라이언트가 요청한 것이 무엇인지 이해한 후에는 대략적이고, 꾸밈없는 모델을 만들어 보라.
  * 이는 추정에 도움을 줄 것이고, 조직이 개발을 하는 동안 사용할 디딤대가 되어줄 뿐만 아니라 시스템을 어떻게 구현해야 할지에 대한 대략적인 그림을 제공해 줄 것임.
  * 모델을 만드는 과정에서 표면에 정확히 드러나지 않았던 이면의 패턴과 프로세스를 발견하게 될 것임.
  * 이 과정에서 좀 더 좋은 방면으로 일정이 줄어들 가능성도 있다. (물론 반대의 경우도 있을 것이다.)
  * 모델을 어디까지 정교화할 것인지는 경험이 이야기해 줄 것이다.
* 모델을 컴포넌트로 나누어라
  * 모델을 컴포넌트로 분해할 수 있고, 이들이 어떻게 상호작용하는지에 대해 기술해주는 수식을 찾을 필요가 있다.
  * 이를 통해 컴포넌트 간 교환해야 하는 데이터 형식, 각 컴포넌트 간 영향도 등을 미리 예측할 수 있을 것이다.
* 각 매개 변수에 값을 주어라
  * 프로젝트에 큰 영향을 미칠만한 매개 변수가 무엇인지 규명하고, 이 매개 변수의 값들을 최대한 정확히 산출해내는 것이다.
    * 데이터 양, 데이터 속도, 트랜잭션 양 및 초당 횟수, 한 개의 트랜잭션을 처리하기 위해 걸리는 속도 등...
* 답을 계산하라
  * 매개 변수를 상세화 해서 답을 계산해라. (하드웨어 환경, 통신 속도, 계산 단위 등...)
  * 계산 단계에서 언뜻 이상해 보이는 답을 얻을 수도 있다. 계산이 정확하다고 판단이 되면, 아마도 문제를 잘못 이해했거나 모델이 잘못되었을 것이다. 이는 중요한 정보이다.
* 추정치는 기록하는 용기
  * 추정치가 잘못되었더라도 움츠리거나 도망가지 마라. 왜 여러분의 추측과 실제 값이 달라졌는지 원인을 찾아야 한다.
* 프로젝트 일정 추정하기
  * 추정에 대한 일반 법칙은 변화하는 어플리케이션 복잡성과 변덕스러움 앞에 와해되기 쉽다.
  * 프로젝트 일정을 정할 수 있는 유일한 방법은 진행하는 해당 프로젝트를 경험하는 것뿐이다.
  * 집중적 개발을 반복한다고 생각해라.
    * 요구사항 체크하기
    * 위험 분석하기
    * 설계, 구현, 통합
    * 사용자가 함께 검증하기
  * 처음부터 완벽하게 만들 수는 없으므로, 초기 기능의 구현과 테스트를 마친 후, 이를 첫 번째 반복의 끝으로 삼아라
    * 이 경험에 기반해 반복의 횟수와 각 반복에서 무엇을 할지에 대한 초기 추측을 다듬을 수 있다.
    * 코드와 함께 일정도 반복하여 조정할 수 있어야 한다.

## 3. 기본적인 도구
### 14. 일반 텍스트의 힘
* 일반 텍스트를 사용하면 우리가 원하는 거의 모든 도구를 이용해서, 수작업과 프로그램을 통한 방법 모두로 지식을 조작할 수 있는 능력이 생긴다.
* 일반 텍스트
  * 잘 정의된 구조를 가진 텍스트는 아주 좋은 지식 정보를 저장하는 방식이다.
* 단점
  * 압축된 이진 포맷을 사용하는 것 보다 더 많은 공간을 차지할 수 있다.
  * 텍스트 파일을 해석하는 데에 더 많은 계산이 필요할 수 있다.
    * 계산에 들어가는 비용보다 더 많은 이득을 얻을 수 있는 경우도 있다. (메타데이터 & 메타프로그래밍)
  * 텍스트 정보 중 중요한 정보는 암호화해서 저장하면 된다.
  * 호환성
    * 텍스트를 다룰 수 있는 도구는 너무 많다.
    * diff, fc등을 통한 비교
    * sum, md5sum 등을 통한 무결성 검사
* 최소 공통문보
  * 시간과 공간에 상관없이 텍스트 정보는 언제나 살아남을 것이다.

### 15. 조개 놀이 (Shell Games)
* 텍스트 파일들을 다루는 프로그래머에겐 명령어 쉘이 작업대가 된다.
  * 파이프를 이용하여 원 개발자가 생각하지 못한 방식으로 도구를 결합할 수 있다.
  * 시스템의 상태도 확인할 수 있다.
  * 출력을 필터링 할 수 있다.
* GUI의 장단점
  * 장점 : What You See is What You Get (당신이 보는 것이 당신이 얻는 것)
  * 단점 : What You See is All You Get (당신이 보는 것이 당신이 얻는 것)
* 사용하는 도구 범위 이상으로 작업 범위를 가져가기 힘들다.
* GUI가 지원하지 않는 작업은 Shell의 명령어 조합으로 아니면 직접 스크립트를 작성하여 구현할 수도 있을 것이다.

### 16. 파워 에디팅
* 자신이 사용하는 에디터의 다양한 기능을 잘 사용하는게 작업 효율을 늘리는 데 도움이 많이 된다.

| 만약 자신이 이렇다면.. | 이걸 고려해 보라... |
| ---                    | ---                 |
| 나는 여러 개의 에디터에서 기본적인 기능 만 사용한다. | 강력한 에디터 하나를 골라서 그걸 제대로 익혀라. |
| 선호하는 에디터가 있긴 한데, 그 기능을 모두 사용하지 않는다. | 그걸 배워라. 입력해야 하는 키 개수를 줄여라. |
| 선호하는 에디터가 있고 가능하다면 그걸 사용한다. | 이미 하는 작업 외에 좀 더 많은 작업에 사용하도록 확장해보라. |
| 나는 여러분들이 바보라고 생각한다. 윈도우 메모장은 이제까지 만들어진 에디터 가운데 최고다. | 여러분이 그 에디터를 사용하면 행복하고, 또 생산적이라면 그걸 사용해라. 하지만 스스로 '에티터 선망'에 걸릴 수 있다는 생각이 들면 스스로의 위치를 재평가할 필요가 있을 것이다. |

### 17. 소스 코드 관리
* 관리할 수 있는 모든 파일을 소스 관리 시스템에 등록하여 사용하자.

### 18. 디버깅
* ***<mark style="color:red; background-color:lightblue;">가정하지 마라. 증명하라!</mark>***
* 아무도 완벽한 프로그램을 만들 수는 없다! 그러므로 디버깅은 아주 중요하다.
* 디버깅의 심리
  * 풀어야 할 퍼즐로 공략하는 대신 부정, 지목, 어설픈 변경 혹은 냉담 같은 것으로 대하게 될 것임.
  * 디버깅은 단지 문제 해결이라는 사실을 포용하고, 그 방식으로 공략하라.
  * 사람을 공격하지 말고, 문제를 공략하라.
* 디버깅 사고 방식
  * 디버깅을 할 때에는 외부 요인에 영향을 받지 말아야 한다. 
  * 일이 일어 났으면, 일어난 것이다.
  * 디버깅을 할 때 근시를 조심하라.
* 어디에서 시작할까
  * 빌드 시 경고문을 주시하라. (경고 레벨을 최고로 높히고 보는 것을 추천한다.)
  * 우리는 좀 더 어려운 문제를 해결하는 데 집중해야 한다.
  * 객관적인 자료를 수집하는 것이 우선이다.
  * 실제로 버그를 재현하는 것이 중요하다. (필요 시 주변 사람의 도움을 받자.)
  * 책에서의 실제 사례에서의 교훈 두가지
    * 버그 리포트를 완벽히 이해하기 위해 버그를 제보한 사용자를 인터뷰 할 필요가 있다.
    * 인공 테스트만으로는 버그를 재현할 수 없다. 해당 문제의 경계 조건과 최종사용자 사용 패턴을 철저히 테스트해야 한다.
* 디버깅 전략
  * 데이터를 가시화 하라
    * 프로그램이 뭘 하는지, 혹은 뭘 할 것인지 알아내는 가장 쉬운 방법은 데이터를 잘 살펴보는 것이다.
    * 디버거를 사용하면 더욱 더 잘 확인할 수 있을 것이다. (시각화를 하면 더 잘 보일 것이다.)
    * 없으면 직접 시각화를 해보는 것도 좋은 방법이다.
    * 주변/이웃 데이터도 시각화하면 문제를 해결하는 데 도움이 될 것이다.
  * 트레이싱 (Tracing)
    * 일관적이고 규칙적이어야 한다.
    * 특히 디버거를 연결할 수 없는 시스템이라던지, 동시성 프로그램, 실시간 프로그램, 이벤트 기반 프로그램 등 시간이 중요한 시스템에서라면 유용한 방식이다.
    * 자원 할당/해제 상황에서 로그를 기록하면 문제 해결에 좋은 영향을 미칠 수 있다.
  * 고무 오리
    * 아무런 대답을 하지 않고 고개만 끄덕이는 고무 오리에게 코드가 무엇을 해야하는 지 설명해봐라.
    * 설명하다 보면, 명시적으로 과정을 이야기 하게 될 것이고 이에 문제에 대한 새로운 통찰을 얻을 수도 있을 것이다.
  * 제거 과정
    * 프로그램 (특히 대형 프로그램/시스템)에는 자신의 코드, 다른 사람의 코드, 써드 파티의 코드, 운영체제 라이브러리 등 여러 사람이 작성한 코드가 관여되어 있을 것이다.
    * 프로그램에서 문제가 생겼을 경우 우선 자신의 코드에서 문제를 찾을려고 노력하자. 특히 운영체체 라이브러리에 문제가 있을 확률은 굉장히 낮다.
      * 발굽 모양을 보면 말부터 생각해야지 얼룩말부터 생각하지 말자.
    * OS, 컴파일러, 데이터베이스 혹은 써드파티 버전 업그레이드 및 변경은 보수적으로 진행하라.
      * 이들의 변경으로 작성한 프로그램이 오류가 발생할 수도 있고 없던 버그가 생길 수도 있다.
      * 그러므로 진행해야 한다면 테스트 계획을 면밀히 세워야 한다.
* 놀람의 요소
  * 놀라운 버그를 마주치면, 단순히 그걸 고치는 것을 넘어서, 왜 이 실패가 더 일찍 발견되지 않았을까 생각해 볼 필요가 있다.
  * 동일한 버그가 있을만 한 코드가 생각난다면, 바로 수정해라.
  * 버그를 수정하는데 시간이 긴 시간이 걸린다면 왜 그런지 자문하라.
    * 다음번에는 이 버그를 좀 더 쉽게 고칠 수 있도록 하는 방법이 무엇이 있을 지 생각하라. (테스팅 및 로깅)
  * 누군가의 잘못내린 가정에 의해 발생했다면, 팀과 공유하고 토론하라.

### 19. 텍스트 처리
* 중요 기반 기술 : 재빨리 필요 유틸리티를 만들고 아이디어를 프로토타입해 볼 수 있다.
  * Tcl, Perl, awk / sed, Python 등...
* 실제 예시
  * 데이터베이스 스키마 관리
  * 자바 속성 엑세스
  * 테스트 데이터 생성
  * 서적 집필
  * 한 언어에서 다른 언어로의 인터페이스 코드 전환 (ex> C에서 Pascal로 전환)

### 20. 코드 생성기
* 같은 정보를 다른 여러 곳에서 반복해야 할 때는 어떻게 해야 할 까?
* 두 가지 유형
  * 수동적 코드 생성기 : 결과를 내기 위해 한 번만 실행한다. 그 결과물은 독립적으로 된다.
  * 능동적 코드 생성기 : 코드 생성이 필요할 때마다 작동한다. 어떤 형태의 스크립트나 컨트롤 파일을 읽어서 결과물을 만들어 낸다.
* 수동적 코드 생성기
  * 기본적으로 몇 개의 입력에서 주어진 출력을 생성하는 매개 변수화된 템플릿임.
  * 용도
    * 새 소스 파일 생성 (snippet) : 프로젝트에서 새로운 파일을 만들 때마다 템플릿, 소스코드 제어 지시자, 지적재산권 문구, 기본적으로 들어가는 주석을 자동으로 만들어 줌.
    * 프로그래밍 언어간 일회용 변환을 수행 : 책을 만들때 troff에서 Latex로 변경하는 코드 생성기를 만들어 사용함.
    * 런타임에 계산하기엔 비용이 많이 드는 참조 테이블 생성 : 삼각함수 결과 테이블을 생성하는 도구
* 능동적 코드 생성기
  * 어떤 지식을 단 하나의 형태로 만들고, 이를 사용 목적(언어)에 맞게 변환해야 할 때에는 어떤 도구를 사용해야 하나?
* 코드 생성기가 꼭 복잡할 필요는 없다.
* 코드 생성기가 꼭 코드를 생성할 필요는 없다.

## 4. 실용주의 편집증
### 21. 계약에 의한 설계
* 아이펠 [ (Eiffel)](https://en.wikipedia.org/wiki/Eiffel_(programming_language))에 계약에 의한 설계 개념을 개발되어 있음.
  * 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈들의 관리와 책임을 문서화하는 데에 초점
  * 루틴이 갖춰야 할 조건
    * 선행조건 (precondition) : 루틴의 선행조건이 위반된 경우에는 루틴이 호출되어서는 안 된다. 제대로 된 데이터를 전달하는 것은 호출하는 쪽의 책임.
    * 후행조건 (postcondition) : 루틴이 완료되었을 때 세상의 상태. 루틴은 결국 종료될 것이라는 의미를 포함한다.
    * 클래식 불변식 (class invariant) : 루틴이 종료하고 호출자로 제어권이 반환되는 때에는 불변식이 참이 되어야 한다.
* iContract
* 무슨 일이 벌어지든지 간에 계약에 부응하지 못하는 게 버그가 되어비르는 실수는 저지르지 말라.
* 게으른 코드 (lazy code) : 시작하기 전에 자신이 수용할 것에 대해서는 엄격하게 하고, 내어줄 것에 대해서는 최소한도를 약속하는 것이다.
* 서브클래스는 자신의 부모 이상으로 받아들이고 최소한 자신의 부모만큼은 보증해야 한다.
* DBC 구현
  * DBC를 사용하는 최고의 장점은 요구사항과 보증의 문제를 전면으로 내세운다는 것이다.
  * 설계 시기에 나열하는 것만으로도 더 나은 소프트웨어를 작성하는 데에 엄청난 도움이 될 것이다.
  * 결국을 설계 기법이다!
  * 단정문
    * 단정문을 사용하면 부분적으로 흉내낼 수 있다.
    * 객체 지향 프로그래밍 언어에서는 단정문을 서브클래스로 전파되도록 하는 지원이 없다. : 진짜인가?
  * 언어지원
    * Eiffel 언어는 이를 지원한다.
    * 책에서는 Nana (C, C++), iContract (Java)를 예시로 보여준다. (현재 프로젝트에 사용되는 일이 있는가?)
* DBC와 일찍 멈추기
  * 계약에 맞지 않는 값이 루틴이 전달되는 상황에 예외를 발생시키며 문제 원인을 표시하도록 구현하면 좋다.
* 불변식의 다른 용도
  * 루프 불변식 : 코드에 별도로 불변식을 작성하여 루프가 정상적으로 돌아갈 수 있는 조건을 기록
  * 의미론적 불변식 : 요구사항에 대한 불변식
    * 이를 작성할 때에는 모호한 점이 없게 진술하도록 하라.
* 동적 계약과 에이전트
  * 계약 역시 설계되어야 명확한 소프트웨어가 작성될 수 있다.
* 도전해 볼 것
  * 계약을 작성하기가 어려운가? 그것이 당장은 신경 쓰고 싶지 않은 문제들에 대해 ***생각***하도록 만드는가? (***생각***하자!)

### 22. 죽은 프로그램은 거짓말을 하지 않는다.
* 실용주의 프로그래머는 만약 에러가 있다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기한다.
* 망치지 말고 멈추라
  * 가능한 한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있다는 이득이 있다.
  * 프로그램을 멈추는 것이 할 수 있는 최선일 때가 많다.
  * 필요하면 예외 처리를 하고 종료해라 (로그 메시지 기록, 트랜잭션 정리, 자원 정리 등...)

### 23. 단정적 프로그래밍
* 코딩할 때에는 자기기만을 훈련하지 말자. (세상에는 모든 일들이 일어날 수 있다!)
* 단정문을 써라! : 절대로 일어나지 않을 것이라는 확신이 드는 부분에 대해서 작성해라.
* 정상적인 에러 처리는 에러로 처리하자.
* 단정이 실패할 때
  * 무조건 바로 프로그램을 종료할 필요는 없다. : longjmp 하거나, 에러 핸들러를 호출하도록 하자.
* 단정 기능을 켜두라
  * 테스트가 모든 프로그램 버그를 찾아낼 수 없다. : 프로그램은 험한 세상에서 돌아간다.
* 작성할 때 하이젠버그(heisenbug)를 생성하지 말자! : 디버깅 코드가 버그를 만들면 안된다!

### 24. 언제 예외를 사용할까?
* "루틴 하나에 리턴문 하나만" : 코드의 깊이가 깊어지면서 코드 가독성이 떨어지는 결과를 나타낸다.
  * try, catch 등을 사용하면 코드 가독성이 높아지고 에러 처리가 명확해질 것이다.
  * C 등 예외 처리를 지원하지 않는 언어는 어떻게 해야하나?
* 무엇이 예외적인가?
  * 정상적이 환경에서 프로그램이 동작한다고 가정할 때, 일어나면 안되는 일은 예외다.
    * 정상적인 환경에서는 통신 에러 (전송 실패, 연결 실패 등...), 파일 에러 (필수 파일 열기 실패, 권한 없음) 등은 일어날 수 없다.
  * 에러 : 일반 파일 없음. 수신한 데이터에 원하는 정보 없음. 등...
* 에러 처리기는 또 다른 대안이다.
  * 에러 처리기 : 에러가 감지되었을 때 호출되는 루틴
  * Java RMI : 로컬 및 리모트 루틴에 대한 에러 처리기를 동시에 작성해야 한다.
* longjmp / setjmp : setjmp에 catch 문을 구성하고 에러 발생 시 longjmp 호출하는 방식으로 비슷하게 흉내낼 수 있다.

### 25. 리소스 사용의 균형
* 개발자들은 리소스 할당과 해제를 다루는 일관적인 계획을 가져야 한다!
* 시작한 것은 끝내라! : 할당한 주체가 해제도 책임져야 한다.
  * C++의 경우 소멸자가 수행하도록 작성해라!
* 중첩 할당
  * 리소스를 할당한 순서의 반대로 해제하라.
  * 코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게하라. 그런 Deadlock 가능성이 줄어들 확률이 높아질 것이다.
* 객체와 예외
  * 특정 리소스 타입이 필요할 때마다 스코프안에서 생성, 소멸되도록 구현해라.
* 균형과 예외
  * 예외가 발생한 경우 예전에 할당된 자원이 모두 해제될 것이라는 보장이 있나? 스스로에게 질문할 필요가 있다.
  * C++ : 로컬 스코프를 이용하라. 스마트 포인터를 사용해라.
  * Java : try/finally구문, Finalizer → Cleaner
* 리소스 사용의 균형을 잡을 수 없는 경우
  * 동적 자료 구조형을 사용하는 프로그램에서는 리소스 사용의 균형을 어떻게 챙길 것인가?
    * 메모리를 여러 모듈에서 다중적으로 할당하는 경우
  * C언어의 경우, 중요한 구조마다 표준적인 할당과 해제 기능을 제공하는 모듈을 하나씩 작성하는 것이다.
  * 레퍼런스 카운팅 기법, 가비지 컬렉션 수행
* 균형을 점검하기
  * 실용주의 프로그래머는 자신을 포함해서 아무도 믿지 않기 때문에, 정말로 리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 작성하면 문제를 해결하는 데 도움이 될 것이다.

## 5. 구부러지거나 부러지거나
### 26. 결합도 줄이기와 디미터 법칙
* 디미터 법칙 (https://en.wikipedia.org/wiki/Law_of_Demeter)
  1. Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.
  2. Each unit should only talk to its friends; don't talk to strangers.
  3. Only talk to your immediate friends.
* 결합도 줄이기
  * 모듈간의 상호작용 정도에 관심을 가져야 한다.
  * 일은 주계약자와 계약하여 진행하자.
  * 의존의 증가는 버그 발생에 대한 시스템 영향도를 증가시킬 것이다.
    * 필요한 정보는 다른 모듈을 통해서가 아닌 관련 모듈에 직접 물어보자.
  * 불필요한 의존이 있으면 제거하자.
* 디미터 함수 법칙
  * shy code를 작성하자.
* 확실히 차이를 낳는가?
  * 분명 문제 범위를 줄이는 데에는 효과가 있을 것이다.
  * 단 디미터 법칙을 어겨서 얻을 성능의 이득이 크다고 판단되면 이를 어겨도 좋을 지 다시 생각해보자.

### 27. 메타프로그래밍
* 세부사항을 코드에서 몰아내라!
* 동적 설정
  * 코드가 설정 가능한 상태면 유연해질 것이다.
  * 메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉토리와 같은 어플리케이션 설정 옵션을 기술하라.
  * 메타데이터는 런타임에 접근, 사용된다.
* 메타데이터 주도 어플리케이션
  * EJB (엔터프라이즈 자바 빈즈)
* 협동적 설정
  * 소프트웨어가 스스로 환경에 적응하도록 만들면 더욱 더 단단한 소프트웨어가 될 것이다.
* 도도 코드를 작성하지 말라.
  * 메타데이터를 사용하지 않는다면 유연성, 적응성이 떨어지고 이에 환경 변화가 일어날 경우 프로그램은 비정상 동작할 것이다.
  * 프로젝트, 경력이 도도의 전철을 따르지 않도록 하라!

### 28. 시간적 결합
* 소프트웨어의 설계 요소 자체로서의 시간의 역할
  * 동시성 : 같은 시각에 일어나는 일들
  * 순서 : 시간 속에서 일들의 상태적 위치
* 일반적으로 프로그래머는 직선적인 사고를 하기 마련이다.
  * 이는 시간적 결합을 만들게 될 여지가 있다.
* 필요 시에는 동시성을 허용할 필요가 있고 시간이나 순서에 따른 의존성의 결합을 끊는 방법을 생각할 필요가 있다.
  * 유연성을 얻을 수 있고, 개발의 여러 측면에 있어 시간과 관련된 의존성을 줄일 수도 있다.
* 작업 흐름
  * 활동 다이어그램 (Activity Diagram)을 보면 동기화 막대로 이르는 모든 활동들이 완료된 후에야 다음 단계를 진행할 수 있다. (https://en.wikipedia.org/wiki/Activity_diagram)
  * 작업 흐름 분석을 통해 동시성을 개선할 수 있다.
* 아키텍처
  * 3중 티어, 다중처리 분산 어플리케이션 (https://en.wikipedia.org/wiki/Multitier_architecture)
  * 배고픈 소비자 모델 : 여러 개의 독립적인 소비자 작업들과 중앙집중식 작업 큐 (Work queue)
    * 이로 인해 컴포넌트들간에 시간적 결합이 끊어지는 효과를 누릴 수 있다.
* 동시성을 고려한 설계
  * 동시성을 염두에 둔다면 여러 가지 일들을 더 주의 깊게 생각하게 될 수밖에 없다.
    * 전역 변수가 필요했는가?
    * 호출 순서와 관계없이 일관성 있는 상태 정보를 보일 수 있나?
  * C strtok은 thread safe하지 않다. (내부 static buffer를 사용한다.)
  * Java의 StringTokenizer는 더 깔끔하고, 유지보수학 쉬운 인터페이스다.
* 배치
  * 시스템을 독립적인 서비스들로 구성된 아키텍처로 만듦으로써, 설정 역시 동적으로 만들 수 있다.

### 29. 단지 뷰일 뿐이야
* '잘 정의된 단 하나의 책임만 가지는 것'이라는 말이야말로 모듈에 대한 좋은 정의가 된다.
* 좋은 모듈들을 작성한 다음, 모듈간의 통신은 어떻게 구현해야 하나?
* 출판 / 구독 (Publish / Subscribe)
  * 객체가 자기가 필요한 이벤트들만 구독해서 받아보고 필요하지 않은 이벤트들은 받아오지 않도록 해야 한다.
    * 그렇지 않으면 모든 메시지를 처리하기 위해 객체는 비대해 질 것이다.
* 모델 - 뷰 - 컨트롤러
  * [위키피디아](https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC)
  * 모델 : 데이터 그 자체
  * 뷰 : 데이터를 보여줌.
  * 컨트롤러 : 모델과 뷰간에 조정 (양방향)
* GUI를 넘어서
  * 일반적인 프로그램 작성시에도 도입할 수 있다.
  * 뷰는 모델을 해석하는 방식이다.
  * 컨트롤러는 조정 작용을 하는 메커니즘
  * 모델은 객체를 나타내는 추상 데이터 모델. 뷰와 컨트롤러에 대한 직접적인 지식을 지니지 않는다.
* 여전히 결합 중
  * 예를 들어 자바에서는 두 쪽이 공통의 인터페이스 정의와 호출방식에 동의하고 있어야 한다.

### 30. 칠판
* 칠판에는 어떠한 주체도 기록할 수 있다.
* 칠판에 올려도 되는지에 대한 제한이 없다.
* 칠판 시스템을 이용하면, 지식의 소비자와 생산자들이 '익명'으로 그리고 '비동기적'으로 데이터를 주고받는 공간이 생긴다.
  * Linda (https://en.wikipedia.org/wiki/Linda_(coordination_language)#Implementations) :  Tuple Space
  * 병렬 컴퓨팅 및 분산 프로그래밍 기법에서 사용된다.
* 다양한 분산 어플리케이션 종류와 상관없이 데이터에 관련된 코드를 일관되게 작성할 수 있게 된다.
  * 작성해야 하는 코드도 줄어들게 된다.

## 6. 코딩하는 동안 해야 할 일들
### 31. 우연에 맡기는 프로그래밍
* 우연에 맡기는 프로그래밍, 곧 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다.
  * 의도적으로 프로그래밍을 해야 한다.
* 왜 코드가 잘 돌아가지 않게 되었는지 모르는 까닭은, 코드가 처음부터 왜 잘 돌아가는지도 몰랐기 때문이다.
* 우연적 구현
  * 문서화되지 않은 에러나 입력값이 특정한 조건에서만 돌아기는 경우
  * 혹시 버그나 문제점이 발견되었을 때 행동을 취해야 할 이유
    1. 정말 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것처럼 보일 수도 있다.
    2. 여러분이 의존하는 조건이 단지 우연인 경우도 있다. 다른 상황에서는 이상하게 작동할지도 모른다.
    3. 문서화되지 않는 동작은 라이브러리의 다음 릴리즈에서 변경될 가능성이 있다.
    4. 불필요한 추가 호출은 코드를 더 느리게 만든다.
    5. 추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다.
  * 다른 사람의 루틴을 호출할 때도 문서화된 동작에만 의존하라.
    * 그럴 수 없는 경우가 생긴다면, 여러분의 추측을 문서로 상세히 남겨라.
* 우연적 맥락
  * 확실한 것이 아닌데도 의존하고 있는 다른 것들은 어떤 것이 있을까?
* 암묵적인 가정
  * 사람들은 마음속에서 많은 것을 가정하고 작업한다.
  * 문서화되는 경우는 드물며 개발자들간에 가정이 다를 수 있다.
  * 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.
* 의도적으로 프로그래밍 하기
  * 언제나 자기가 무엇을 하고 있는지 알아야 한다.
  * 맹목적으로 코딩하지 말라. : 완벽하게 이해하지 못한 어플리케이션을 빌드하거나 익숙하지 않는 기술을 사용하는 것을 자신 스스로를 미혹하는 것이다.
  * 계획을 세우고 그것을 바탕으로 진행하라.
  * 신뢰할 수 있는 것에만 기대라.
  * 여러분의 가정을 문서로 남겨라. : 다른 사람과 소통하는데 도움이 될 뿐더러, 자신의 마음속에서 가정을 명확하게 하는 데에도 도움이 될 것이다.
  * 여러분이 세운 가정도 테스트를 해야 한다.
  * 노력을 기울일 대상의 우선순위를 정하라.
  * 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말아라.

### 32. 알고리즘의 속도
* 프로그래머는 프로젝트 일정만 아니라 코드에 적용할 알고리즘이 사용하는 자원 (시간, 프로세서, 메모리 등) 에 대한 추정도 해야한다.
* 알고리즘을 추정한다는 말의 의미는 무엇인가?
  * 입력의 크기는 알고리즘에 영향을 준다.
* 많은 알고리즘이 선형보다 증가폭이 적다.
  * 이진 검색은 일치되는 항목을 찾을 때 모든 후보를 다 살펴볼 필요가 없다.
* 또 다른 알고리즘들은 선형보다 훨씬 심각한 경우도 있다.
* $O()$ 표기법
  * $O()$ 표기법(시간, 메모리, 기타 등등)은 우리가 측정하는 것의 상한값을 정하는 표기법이다.
  * 레코드 100 개를 처리하는데 1초가 걸리는 루틴에 대해 1000 개를 처리하는데 걸리는 시간을 계산하다면...
    * $O(1)$ : 어떤 경우라도 1초
    * $O(n)$ : 항목 수와 비례함. 10초
    * $O(lg(n))$ : 대략 3초 정도
    * $O(n^2)$ : 100초
    * $O(2^n)$ : 대략 $10^{263}$초 정도
* 상식적인 추정
  * 간단한 반복문 : $O(n)$
  * 겹친 반복문 : $O(n^2)$가 되기 쉽다. (버블 정렬, 선택 정렬, 삽입 정렬)
  * 반씩 잘라 나가기 : $O(lg(n))$ (이진 트리 순회, 이진 검색)
  * 나눠서 정복하기 : $O(nlg(n))$ (퀵 정렬, 병합 정렬, 힙 정렬)
  * 조합적 : 피보나치 수열
* 실전에서의 알고리즘 속도
  * 실제 필드에서는 이미 나와 있는 라이브러리에 들어 있는 정렬 루틴이 아마 직접 작성하는 것보다 성능이 좋을 것이다.
  * 스스로 채용한 알고리즘이 외부 요인에 따라 실행 성능이 달라진다면, 잠시 작업을 멈추고 커다란 수가 들어왔을 경우, 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해 보는 것이 좋다.
  * 현장에서 실제 데이터를 입력받아 돌아가는 코드의 수행시간만이 정말로 의미있는 수치다.
    * 입력 데이터 집합이 작을 때는 수행시간이 선형적으로 증가하다가도, 수백만 개의 레코드를 입력하면 시스템이 버벅이기 시작하면서 갑자기 수행시간이 길어질 수도 있다.
  * 추정을 테스트하라! (코드 프로파일러를 사용해봐라. ex> strace의 시스템 콜 횟수 카운팅)
* 최고라고 언제나 최고는 아니다.
  * 선택한 알고리즘이 입력 데이터를 알고리즘이 요구하는 형식으로 준비하는 데 비용이 많이 드는 것은 아닌지 주의 깊게 보아야 한다.
  * 성급한 최적화를 조심하라. : 어떤 알고리즘을 개선하기 전에 그 알고리즘이 정말로 병목인지 확실히 검토하라.
    
### 33. 리팩터링
* 소프트웨어는 건축보다는 오히려 정원일에 더 가깝다. 딱딱하기보다는 유기적인 존재다.
* 리팩터링은 언제 해야 하는가?
  * 어떤 것이든 '잘못'되었다고 생각될 때, 그것을 변경하는 일을 주저하면 안 된다.
    * 중복
    * 직교성이 좋지 않은 설계
    * 유효기간이 끝난 지식
    * 성능
  * 고통을 피하지 말자. : 항상 즐거운 일이 아니다.
  * 현실 세계의 복잡한 문제들
    * 지금 리팩터링을 하지 않으면, 일이 더 진척되었을 때, 곧 신경 써야 할 의존성이 더 많이 생겼을 때 문제를 고치기 위해 훨씬 더 많은 시간을 투자해야 한다.
    * 리팩터링해야 할 것들의 명단을 만들고 유지하라.
* 리팩터링은 어떻게 하는가?
  * 리팩터링은 천천히, 신중하게, 조심스럽게 진행해야 하는 작업이다.
  * 리팩터링에 대한 조언
    1. 리팩터링과 새로운 기능 추가를 동시에 하지 말라.
    2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다.
    3. 단계를 작게 나누어서 신중하게 작업한다.
  * 수준에 못 맞추는 코드를 보게 되면, 그 코드와 더불어 그 코드에 의존하는 모든 것도 함께 고치도록 한다.

### 34. 테스트하기 쉬운 코드
* 단위 테스트
  * 단위 테스트란? : 모듈에 이것저것을 시켜보는 코드를 가리킨다.
  * 단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴을 호출한다.
  * 그리고 예상되는 값이 나왔는지 확인하거나, 이전에 테스트했던 값과 비교하여 올바른지 검사한다.
* 계약을 잘 지키는지 테스트해 보기
  * 단위 테스트를 계약을 잘 지키는지 보는 테스트로 생각하길 좋아한다.
  * 테스트 케이스를 작성하는 데 계약을 검토하게 된다.
    * 코드가 계약을 지키는지
    * 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는 지
  * 복합적인 모듈에 대한 테스트는?
    * 하위 컴포넌트를 먼저 테스트하라.
    * 문제가 없다면 최상위 모듈 자체를 검사하라.
  * 모듈을 설계할 때는, 심지어 루틴 하나를 설계할 때도, 그것이 지켜야 할 계약과 계약을 지키는지 테스트하는 코드도 함께 설계해야 한다.
* 단위 테스트 작성하기
  * 단위 테스트는 찾기 편한 곳에 위치하고 있어야 한다.
  * 규모가 작은 프로젝트라면 각 모듈에 테스트코드를 직접 포함시켜도 된다.
  * 규모가 큰 프로젝트라면 별도의 디렉토리에 테스트 코드를 모아서 수행하는게 좋다.
  * 테스트 코드 접근이 쉽다면?
    1. 여러분 모듈의 모든 기능을 어떻게 이용해야 하는지 모여주는 예제
    2. 후일 코드 변경시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단
* 테스트 장치(Test Harness)를 사용하기
  * 테스트 장치는 상태를 기록으로 남기거나, 예상 결과값에 비추어 출력을 분석하거나, 테스트를 선택하고 실행하는 일처럼 자주 쓰이는 작업들을 다룰 수 있어야 한다.
  * 테스트 장치라면 반드시 다음과 같은 기능이 있어야 한다.
    * 시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법
    * 개별적인 테스트들을 선택하거나, 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메서드
    * 예상한 (또는 예상하지 못한) 결과에 비추어 결과를 분석할 수 있는 방법
    * 실패를 보고하는 표준화된 형태
  * JUnit (https://ko.wikipedia.org/wiki/JUnit)
* 테스트 윈도우를 만들기
  * 코드가 돌아가는 현장은 우리가 모르는 버그를 발생시킬 환경을 가지고 있다.
  * 추적 메시지는 반드시 규칙적이고 일관된 형식이어야 한다.
  * GUI의 경우 특정한 키조합을 만들어 유지 보수에 활용할 수 있게 할 수 있다.
  * 서버 코드의 경우 별도의 웹 인터페이스를 포함하여 문제 정보를 확인할 수 있게 만들 수도 있다.
* 테스트 문화
  * 소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다.
  * 언어 및 빌드 과정에서 테스트를 수행할 인터페이스가 있으면 더 좋을 것 같다. [^3]

### 34. 사악한 마법사
* 어플리케이션을 작성하는 일은 날이 갈수록 힘들어지고 있다.
  * 사용자 인터페이스는 점점 복잡해지고 있다.
  * 어플리케이션 자체도 점점 더 복잡해지고 있다.
* 구루(Guru)가 설계한 마법사를 사용한다고 평범한 개발자가 자동으로 동등한 수준의 전문가가 되지는 않는다.
* 마법사가 작성한 코드를 모두 이해하지 못했다면, 여러분은 자기 어플리케이션의 주인이 아니다.
  * 어플리케이션을 유지보수하지도 못할 것이고, 디버깅해야 할 때가 오면 고생하게 될 것이다.

## 7. 프로젝트 전에
### 36. 요구사항의 구렁텅이
* 요구사항이 지면에 놓여져 있는 경우는 퍽 드물다. 보통은 가정과 오해, 정치(政治)의 지층들 속 깊이 묻혀져 있다.
* ***<mark style="color:red; background-color:lightblue;">요구사항을 수집하지 말고 채굴하라.</mark>***
* 요구사항 채굴하기
  * 요구사항은 최대한 일반적인 진술로 만들고
  * 나머지 정책에 대한 정보는 메타데이터로 넘겨라. (항상 정책은 변경될 수 있다.)
  * 사용자들이 현재 작업을 어떻게 하느냐보다 작업을 왜 하는지 내재적인 이유를 알아내는 것이 더 중요하다.
  * 더 좋은 방법은 사용자가 되어 보는 것이다.
    * 고객 상담 프로그램을 개발하려고 하면, 며칠간 경험 많은 고객 상담을을 관찰하라. (직접 이야기해보면 더 좋다.[^4])
* 요구사항 문서화
  * 전문가라면 여러 방면의 사람들에게 배포(사람들간에 논의를 위해)를 하기 위해 문서화를 하려 할 것이다.
  * 어떻게 작성하는 게 좋을 것인가?
    * 표기법의 노예가 되면 안된다.
    * 청중과 요구사항을 가장 잘 소통할 수 있는 방법이 있으면 무엇이든 사용하도록 하라.
* 자나치게 자세한 명세
  * 요구사항 문서를 만들 때 생기는 큰 위험은 지나치게 자세히 서술하는 것이다.
  * 요구사항에 관한 비즈니스에 필요한 사항을 가장 간단한 진술문이 최고다.
    * 의미론적 불변식(필수적인 내용)은 요구사항으로 잘 갈무리하고
    * 구체넉인 작업관행이나 현재의 작업관행을 정책으로 문서화해야 한다.
* 더 멀리 보기
  * 구체적인 것보다 추상적인 것이 더 오래간다.
    * Y2K 문제에 관해 아키텍처가 자료 입력, 보고, 저장 등을 위해 두 자리 숫자년도를 필요로 했을지라도, 두 자리 숫자가 실은 날짜를 줄여 쓴 것이라는 사실을 '알고 있는' DATE라는 추상화가 있어야 했다.
* 딱 하나만 더...
  * 요구사항이 슬금슬금 추가되는 것을 어떻게 막을 수 있을까?
  * 요구사항 증가 관리의 핵심은, 새 기능이 일정에 미칠 영향을 프로젝트 후원자에게 인식시키는 것이다.
* 말을 끄집어내라
  * 요구사항을 정리 시 접근하기 쉽게 작성하여 구성원의 반응을 조금이라도 더 이끌어 낼 수 있으면 좋다.

### 37. 불가능한 퍼즐 풀기
* 어려운 문제를 어떻게 풀까?
  * 어려운 퍼즐을 푸는 방법은 실제의 제약 조건을 알아내고, 그 속에서 해법을 찾는 것이다.
* 자유의 정도
  * 생각의 틀을 벗어나라!
  * 여기서의 '틀'은 문제의 제약과 조건들의 경계선을 의미한다면, 우리가 해야 할 일은 그 틀을 파악하는 것이다.
  * 모든 선입견을 의심해보고 그것이 명백한 진짜 제약인지 가늠해 봐야 한다.
  * 플리지 않는 문제와 마주쳤다면, 생각해 볼 수 있는 모든 가능한 해결 경로를 눈앞에 나열해보라.
  * 제약들을 범주별로 나누고 우선순위를 매겨라.
* 분명히 더 쉬운 방법이 있을거야!
  * 문제가 생각보다 훨씬 어렵다는 것을 발견할 때도 있다. 이럴 때는 아래와 같은 생각을 해봐야 할 때이다.
    * 더 쉬운 방법이 존재하는가?
    * 진짜 문제를 풀려고 노력하고 있나.
      * 그렇지 않다면 중요하지 않는 기술적 문제에 정신이 팔려 있는 것인가?
    * 왜 이것이 문제인가?
    * 문제를 이렇게 풀기 어렵게 만드는 것이 무엇인가?
    * 반드시 이 방법으로 해야 하는가?
    * 반드시 해야 하는 일이긴 한가?
  * ***<mark style="color:red; background-color:lightblue;">우리에게 필요한 것은 진짜 제약과 우리를 오도하는 제약 그리고 그 차이를 구별하기 위한 지혜다.</mark>***

### 38. 준비가 되어야만
* 만약 앉아서 키보드를 치기 시작했는데 마음속에 어떤 의심들이 자꾸 거슬린다면 그 느낌을 따르라.
* 소프트웨어 개발은 아직 과학이 아니다. 직감도 훌륭한 도구 중 하나이다.
* 좋은 판단이냐 늑장부림이냐?
  * 모든 사람이 백지를 두려워한다.
  * 많은 사람들이 일을 시작하는 최초 행위를 미루기 좋아한다.
  * 프로토타이핑을 시작해 봐라.
    * 프로토타이핑을 진행하면서 진짜 개발에 뛰어들 동기를 찾을 수 있다.
    * 또는 프로토타이핑을 진행하면서 무언가 잘못되었음을 확인할 수 있다. 이럴 경우 주변에 알리는 것도 좋다.
  * 솔리테어를 실행하는 것보다 프로토타입 작업이라도 시작하는 것이 정치적으로 더욱 용인되는 행동일 것이다.

### 39. 명세의 함정
* 프로그램 명세화란?
  * 어떤 요구사항을 가져와 프로그래머가 자기 기술로 작업을 시작할 수 있는 시점까지 정리하는 과정이다.
* 명세는?
  * 맨 먼저 구현할 개발자들과 하는 대화
  * 미래에 유지보수하고 개선할 프로그래머들을 위한 기록
  * 사용자와 하는 약속
* 명세의 작성에는 굉장히 무거운 책임이 따른다.
* 명세서의 함정
  * 어떤 명서세가 어떤 시스템이나 그 시스템에 대한 요구사항의 모든 세부사항과 미묘한 차이점들을 모조리 잡아낼 수 있으리라고 믿는 것은 너무 순진한 생각이다.
    * 사람들 간의 해석 차이가 존재해서 일을 뒤죽박죽으로 만들 가능성이 있다.
    * 개발하는 주체가 아닌 일반적인 사용자가 자기가 무엇을 원하는지 정확히 알고 있는 상태로 어떤 프로젝트에 참여할 가능성은 매우 낮다는 것이 문제다.
  * 언어로 모든것을 직관적으로 표현할 수는 없다.
    * 어떤 다이어그램 기빕도 형식적 방법도 수행할 작업을 기술하려면 여전히 자연 어어로 된 표현에 의존해야 한다.
    * 신발끈을 묶는 방법을 글로 표현해봐라.
  * 코딩하는 사람에게 해석의 여지를 전혀 남기지 않는 설계는 프로그래밍 노력으로부터 모든 수완과 기술을 빼앗아 버린다.
  * 명세와 구현은 단지 동일한 과정, 즉 요구사항을 포착해서 명문화하는 노력의 다른 측면일 뿐이다. 어떤 측면에서든 인공적인 경계없이 다른 측면으로 흘러갈 수 있어야 한다.
  * 명세의 순환에 빠지지 말라. 언젠가는 코딩을 시작해야 한다!
    * 프로토타이핑 또는 예광탄 방식을 사용해봐라.

### 40. 동그라미와 화살표
* 어떤 기법이든 개발 실천방법과 개발 능력의 맥락 안에 그것을 넣어보지도 않고 맹목적으로 받아들이는 것은 단지 실망을 맛보기위한 비법이라고 믿는다.
* 형식적 방법의 심각한 단점들
  * 대부분의 형식적 방법은 다이어그램과 거기에 추가된 설명의 조합을 이용해서 요구사항을 포착한다.
    * 최종 사용자들은 이런 다이어그램들을 전혀 이해하지 못할 것이므로, 설계자가 해석해 주어야 한다.
    * 이럴 경우 프로토타입 기법을 통해 설명하는 것이 오히려 이해도를 높일 수 있을 확률이 높다.
  * 형식적 방법들은 전문화를 권장하는 것처럼 보인다.
    * 한 집단은 데이터 모델 작업을 하고
    * 또 다른 집단은 아키텍처를 보는 동안
    * 요구사항 수집자들은 유스 케이스를 모은다.
    * 각 집단간의 전문화만을 부각하다 보면, 결국 의사소통의 부족과 노력의 낭비로 이어질 수 있다.
  * 대부분의 형식적 방법들은 동적으로 연결해야 할 객체들 사이에 정적인 관계를 설정하도록 권장하면서 잘못된 길로 이끌 것이다.
* 방법론이 제값을 하는가?
  * 새로운 도구와 방법론을 채택하는 데 들어가는 비용을 절대 과소평가하지 말라.
  * 새로운 기법을 사용하는 최초의 프로젝트를 학습경험으로 여길 마음의 준비를 하라.
* 우리가 형식적 방법을 사용해야 할까?
  * 형식적 방법은 단지 도구 상자 속의 또 다른 도구일 뿐이라는 사실을 늘 기억하라.
  * ***절대로 방법론의 노예가 되지 말라.***
  * 단 항상 자신의 공정을 개선하고 다듬기 위해 끊임없이 노력해야 한다.
  * 절대로 어떤 방법론의 완고한 경계를 여러분 세계의 한계로 받아들이면 안 된다.
  * 결국은 프로그램을 작성하는 것이다.

## 8. 실용주의 프로젝트
### 41. 실용주의 팀
* 깨진 창문을 없애라
  * 팀 전체가 깨진 창문(아무도 고치려고 하지 않는 사소한 결점)을 용납하지 않아야 한다.
* 삶은 개구리
  * 개인 보다는 팀이 삶은 개구리가 되기 쉽다.
    * 누군가는 문제를 처리하겠거니 하고 생각하거나
    * 사용자가 요구하는 변화에 대해 팀 리더가 이미 받았들였을 경우
  * 모든 사람이 적극적으로 환경 변화를 감시해야 한다.
* 소통하라!
  * 잘못된 팀은 (의사소통을 하지 않는 팀) 은
    * 회의를 아무 체계 없이 하고 
    * 아무도 나서서 말하는 이도 없다. 
    * 어떤 문서도 닮은 데가 없고, 
    * 각기 다른 용어를 사용한다.
  * 훌륭한 팀은
    * (팀원 개개인의 준비가 긍정적이고 귀 기울만한 내용 있을 것이라 기대) 회의를 기대한다.
    * 문서는 깔끔하고 정확해서 일관적이다.
    * 팀은 한 목소리로 대외에 이야기한다. (팀 내에서는 생생하고 원기왕성한 토론을 장려한다.)
* 반복하지 마라
  * 팀원 간의 중복된 일을 제거하는 어려움에 대해 이야기했다.
  * 중목은 노력을 낭비하게 되고, 결국 유지보수의 악몽을 끌어들일 수도 있다.
  * 팀 내 프로젝트 사서를 두어 문서와 코드 저장소를 관리하는 책무를 진다.
    * 정보 소통은 사서를 통해 진행하고 이를 거치면서 여러가지 형태의 중복을 방지하거나 제거할 수 있다.
  * 프로젝트가 큰 경우 기능별 핵심 사안 별로 담당을 임명하여 프로젝트 진행 상 중복을 방지하는 방법도 있다.
* 직교성
  * 팀을 기능 중심으로 조직하라.
  * 여러 팀을 나눌 경우, 각 팀은 최종 시스템의 특정한 기능 측면에 대해 책임지도록 한다.
    * 각 팀은 동의된 공약에 정의된 대로 프로젝트의 다른 팀에게 자기 책임을 진다.
  * 코드를 조직할 때처럼 팀도 직교성을 가지고 조직한다.
    * 한 팀에서 변화가 일어나더라도 전체가 영향을 받는 일이 없게 된다.
    * 이 기법은 책임감 있는 개발자들과 강력한 프로젝트 관리가 있을 경우에만 효과가 있다.
  * 프로젝트에는 총괄이 필요하다.(기술 수석 그리고 관리 수석)
    * 기술 수석 : 개발 철학과 스타일을 정하며 팀에 책임을 할당
    * 관리 수석 : PM. 각 팀이 필요한 자원을 계획하고, 전척도를 모니터 하고, 그에 대한 보고하며, 비즈니스 가치의 관점에서 우선순위를 결정하는 데에 도움을 준다. 팀이 바깥 세상과 대화하는 외교관 역할을 한다.
* 자동화
  * 프로젝트의 단조로운 일을 자동화할 도구를 만들고 설치하도록 한다.
* 덧칠을 언제 멈출지 알아라
  * 각 팀원이 자신의 방식대로 빛나게 해 주어라. 단 프로젝트가 요구사항에 맞게 이루어지기에 딱 좋을 만큼의 구조를 제공하라.

### 42. 유비쿼터스 자동화
* 빌드와 릴리즈 과정이건, 코드 리뷰 서류 작업이건, 혹은 프로젝트에서 거듭 발생하는 어떤 종류의 작업이건 간에 그것은 모두 자동화되어야 한다.
* 전자동
  * 스크립트는 동일한 명령을 매번 똑같은 순서로 수행한다. 이는 동일한 동작을 사람들이 행했을 때 실수가 발생할 확률을 없애준다.
  * 또한 소스코드 관리 시스템을 통해 이력관리도 할 수 있다.
  * cron을 통해 필요한 작업을 원하는 시간에 주기적으로 반복 실행할 수 있다.
* 프로젝트 컴파일
  * 자동 빌드 시스템 사용을 통해 일괄적으로 컴파일,빌드,테스트 단계를 자동화 할 수 있다.
* 코드 생성
  * 자동 빌드 시스템 사용을 공통 데이터 파일을 기반으로 소스코드 또는 문서를 자동으로 작성하게 만들 수 있다.
  * 빌드 과정에서의 전체 테스트 과정도 자동 빌드 시스템 사용을 통해 이루어 낼 수 있다.
* 빌드 자동화
  * 빌드 자동화 시 꼭 코드 레벨의 전체 테스트를 수행하도록 하자. 이를 통해 소스 레벨의 문제를 쉽게 찾아낼 수 있다.
  * 최종 빌드
    * 최종 빌드에는 저장소를 잠그고, 릴리즈 번호를 태그로 붙이는 작업이 필요할 수 있을 것임.
    * 이전 버전과 다르게 컴파일된다면, 이 버전에 대해서 전부 다시 테스트해 봐야 한다는 것이다.
* 자동화된 관리
  * 내용 주도인 작업흐름을 유지하는 것
  * 웹사이트 생성
    * 코드에서 추출된 문서나 요구사항 분석, 설계 문서, 그림, 차트, 그래프 등 모두가 ***정기적***으로 웹에 올라가야 한다.
    * 야밤의 빌드에서 생성된 정보는 모두 개발 웹사이트에서 접근할 수 있어야 한다. ([Jenkins](https://en.wikipedia.org/wiki/Jenkins_(software)))
  * 승인 과정
    * 코드와 설계 검토의 일정을 잡고 지켜야 하며, 그 승인을 받아야 한다.
    * 코드 검토의 일정잡기와 승인을 자동화하길 원한다고 가정하면?
      * 책에서는 주석등을 통해 표시하고 이를 스크립트를 통해 추출하여 이를 내부 정보망에 게시하거나 이메일로 알리는 동작을 수행하는 것을 제시하고 있다.
      * 하지만 현재 git의 pull request 같은 기능이 사용되고 있다.
      * 팀내 코드 리뷰는 항상 이루어져야 하는가?
  * 반복적이고 지루한 작업은 컴퓨터에게 시키자.
    * 프로젝트 구성원들은 훨씬 더 중요한 일에 집중할 필요가 있다!

### 43. 가차 없는 테스트
* 개발자 대부분은 테스트를 싫어한다.
* 코드가 어디에서 깨지는지 무의식적으로 알고 약한 지점을 피해다니면서, 살살 테스트하려 한다.
* 코드를 작성하자마자 테스트해야 한다.
  * AI 기술을 통해 코드를 작성하고 이에 대한 테스트케이스를 자동적으로 작성해달라고 할 수 있다.
  * 최근 언어들 중 일부는 테스트 과정을 명시적으로 요구하여 진행하도록 할 수 있다. (https://doc.rust-kr.org/ch11-00-testing.html)
  * 작은 버그가 큰 문제를 만들 수 있다.
* 테스트 코드를 만들기 위해 소요되는 시간에는 그 노력만큼의 가치가 있다.
  * AI 기술을 통해 시간을 많이 줄일 수 있다.
* 테스트를 통과했다는 것은 '그 코드가 완료되었다'라고 말할 수 있는 높은 수준의 확신을 갖게 하는 것이다.\
* 무엇을 테스트 할지
  * 단위 테스트
    * 하나의 모듈을 테스트하는 코드다.
    * 모든 테스트의 근간이다.
    * 이를 모두 통과해야 다음 단계의 테스트로 나아갈 수 있다.
  * 통합 테스트
    * 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여준다.
  * 유효성 평가와 검증
    * 실행가능한 사용자 인터페이스나 프로토타입이 갖춰지자마자 사용자들이 진정으로 필요한 내용인지 확인해봐야 한다.
    * 시스템이 기능적 요구사항을 충족하는지도 테스트해 봐야 한다.
    * 최종 사용자의 접근 방식과 개발자 테스트가 어떻게 다른지도 관심을 두어야 한다.
  * 자원 고갈, 에러, 그리고 복구
    * 이상적인 상황이 아닌 실제 세계에서 상황에서 어떻게 동작할지 생각을 해봐야 한다.
    * 제한 사항 : 메모리, 디스크 공간, CPU 대역폭, wall-clock time, 디스크 대역폭, 네트워크 대역폭, 칼라 팔레트, 비디오 해상도 등...
    * 시스템이 실패할 때, 최대한 우아하게 실패할 필요가 있다.
  * 성능 테스트
    * 소프트웨어가 실세계 조건에서 성능 요구사항들을 만족하는지 확인해야 한다.
  * 사용편의성 테스트
    * 소프트웨어는 실제 환경의 조건 하에서 실제 사용자들이 시행한다.
    * 인간적 요소라는 측면에서 사용편의성을 바라보라.
    * 사용편의성 테스트는 보정할 시간이 있을 때 되도록 일찍 시행해야 한다.
* 어떻게 테스트 할까
  * 회귀 테스트
    * 이전 테스트 값 또는 알려진 갑과 현재의 테스트 출력을 비교하는 테스트이다.
    * 코드 수정이 문제가 기존 동작에 영향이 없었음을 확인할 수 있는 테스트이다.
  * 테스트 데이터
    * 우리는 테스트 데이터를 어디서 얻어야 하나?
    * 실세계 데이터와 합성 데이터
      * 실세계 데이터는 현실에서 온다. 기존 시스템, 경쟁사의 시스템 혹은 어떤 종류의 프로토타입 등에서 자료를 수집한다.
      * 합성 데이터는 어떤 통계적 조건하에서 인공적으로 생성된다.
        * 실세계 데이터보다 많은 데이터가 필요하다.
        * 경계 조건을 테스트할 데이터가 필요하다.
        * 특정한 통계 특성을 보이는 데이터가 필요하다.
  * GUI 시스템 테스트
    * 특화된 테스트 도구가 필요하다.
    * 결합도가 낮은 코드를 작성하는 많은 이점 중 하나는 좀 더 모듈화된 테스트가 가능하게 만든다.
      * front-end와 데이터 처리 어플리케이션 로직의 결합도가 낮아야 테스트도 나누어서 테스트를 진행할 수 있다.
  * 테스트를 테스트하기 
    * 버그를 감지해내는 테스트를 작성한 후에, 그 버그가 의도적으로 생기도록 한 다음 테스트가 불평을 해대는지 확인하라.
    * 프로젝트 파괴자 : 소스에 버그를 심어 테스트가 이를 찾아내는 지 확인하는 담당자
  * 철저한 테스트
    * 충분히 철저하게 테스트했다는 것을 어떻게 알 수 있을까?
      * 답은 '알 수 없다' 이다. 그리고 앞으로도 알 수 없을 것이다.
    * 코드의 모든 라인이 실행될지라도, 그게 전부가 아니다. 정말로 중요한 것은 프로그램이 갖는 상태의 개수이다.
      * 코드 커버리지보다 상태 커버리지를 테스트하라.
* 언제 테스트할까
  * 테스트는 가능한 일찍 시작해야 한다.
  * 테스트는 대부분 자동화되어야 한다. 
    * 테스트 결과 분석도 같이 자동화되어야 한다.
  * 부하 테스트의 경우 특별한 설정과 장비, 지원이 필요할 수 있다.
    * 주기적으로 일정에 따라 실행된다는 점이 중요하다.
* 그물 조이기
  * 현존하는 테스트의 그물을 빠져 나가는 버그가 있으면, 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 한다.

### 44. 결국은 모두 글쓰기
* 실용주의 프로그래머들은 문서화를 전체 개발 프로세스의 필요불가결한 부분으로 포용한다.
  * literate programming
  * JavaDoc (https://en.wikipedia.org/wiki/Javadoc)
    * https://www.youtube.com/watch?v=xIHNUId9RdM&t=214s
  * https://en.wikipedia.org/wiki/Comparison_of_documentation_generators
* 한국어도 하나의 프로그래밍 언어인 것처럼 다루라.
* 코드 내의 주석
  * 코드에 대한 단순한 설명은 코드가 자체가 설명하는 것이 좋다.
  * 왜 코드를 작성했는지, 추후에 코드를 수정할 사람이 참고해야 하는 사항이라던지, 아니면 코드 외 다른 방법을 왜 포기했는지 등 복잡한 설명을 주석에 기록하는 것이 좋다.
  * 변수도 무의미한 의미를 담지 않도록 하자.
    * 사용자 자료형을 사용할 경우 (예를 들어 C의 struct), 이를 통해 의미를 명확히 하는 것도 좋다.
  * 책에서는 JavaDoc 도구가 제안하는 주석의 수준을 제안하고 있음.

```java
/**
 * Validates a chess move.
 *
 * <p>Use {@link #doMove(int fromFile, int fromRank, int toFile, int toRank)} to move a piece.
 *
 * @param fromFile file from which a piece is being moved
 * @param fromRank rank from which a piece is being moved
 * @param toFile   file to which a piece is being moved
 * @param toRank   rank to which a piece is being moved
 * @return            true if the move is valid, otherwise false
 * @since             1.0
 */
boolean isValidMove(int fromFile, int fromRank, int toFile, int toRank) {
    // ...body
}

/**
 * Moves a chess piece.
 *
 * @see java.math.RoundingMode
 */
void doMove(int fromFile, int fromRank, int toFile, int toRank)  {
    // ...body
}
``` 
  * 특정 저작권 문구나 법적 상투어가 필요한 경우 에디터가 이런 것들은 자동으로 삽입하도록 해야 한다.
* 실행가능한 문서
  * 정보에 대한 권위적인 소스가 필요하다. (명세, 데이터베이스 스키마 도구, 어떤 소스 등...)
    * 이를 기반으로 문서 및 코드를 생성하는 방법을 찾아라.
  * 문서가 마크업 명렁어이면 이를 분석하여 스키마를 추출하고, 그걸 자동으로 다시 포맷할 수 있다.
    * 명세, 스키마, 코드가 모두 일치한다는 보장을 할 수 있다.
* 테크니컬 라이터
  * 실용주의 원칙을 가지고 문서를 작성하길 바란다.
* 찍기나 짜기
  * 종이 문서는 만들어진 순간부터 옛날 정보가 될 수 있다.
  * 전자 문서를 통해 배포하면 문서의 신속성을 얻어낼 수 있다.
  * 모든 문서는 이력을 기록하도록 하자. (수기, 소스 코드 관리 시스템)
* 마크업 언어
  * 문서는 마크업 언어를 사용하는 것을 권고한다.
  * 문서와 코드는 밑에 깔려 있는 모델에 대한 뷰일 뿐이다.

### 45. 위대한 유산
* 프로젝트 성공은 사용자들의 기대를 얼마나 잘 충족하는가에 달려 있다.
  > ***사용자의 기대를 부드럽게 넘어서라.***
* 기대를 상호 소통하기
  * 사용자의 필요에 대한 이해가 깊어질수록, 그들의 기대가 충족될 수 없는 영역이나 혹은 그들의 기대가 너무 보수적으로 보이는 영역을 발견하게 될 것임.
  * 사용자와 협동해서, 그들이 아직 이야기하지 않은 기대까지도 포함해서, 개발 과정과 최종 전달물에 대한 공통된 이해에 도달하도록 하자.
    * 예광탄과 프로토타입 기법을 적절히 이용하자.
* 한 계단 더
  * 기대하는 것보다 조금만 더 해주어라.
    * 약간의 노력을 들여 시스템에 사용자 편의를 위한 기능을 추가하면, 관계가 두고두고 좋아질 것이다.

### 46. 오만과 편견
* 자신의 작품에 서명하라.
* 경계심 때문에 여러분의 코드를 참견자에게서 방어하려고 하면 안 된다.
* 다른 사람들의 코드를 존중해야 한다.
* 익명성은 특히 큰 프로젝트에서 적당주의, 실수, 태만 그리고 나쁜 코드의 번식지가 될 수 있다.
  * ***<mark style="color:red; background-color:lightblue;">이렇게 되면 훌륭한 코드 대신 끝없는 상황 보고 속에서 어설픈 변경만 생산해 내는 거대한 기계의 한 부속품으로 스스로 전락해가기 쉽다.</mark>***
* 코드에 대한 공동 소유권을 가지는 것도 좋다. (하지만 이게 익명성의 위험을 허용한다는 이야기는 아니다.)
* 프로그래머는 결과물의 소유권에 대한 긍지를 가지는 것이 좋다.
* 서명을 통해 잘 작성되고, 제대로 테스트되었으며, 훌륭히 문서화되었다는 보증하는 것을 보여주는 것

---

[^1]: 내 생각, 그리고 앞으로 작성할 텍스트 형식 예제
[^2]: 내 생각
[^3]: 내 생각
[^4]: 내 생각

